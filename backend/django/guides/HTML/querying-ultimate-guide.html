<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>The Ultimate Django Querying Guide</title>
<link rel="preconnect" href="https://fonts.googleapis.com">
<link href="https://fonts.googleapis.com/css2?family=Playfair+Display:ital,wght@0,400;0,700;0,900;1,400;1,700&family=Crimson+Pro:ital,wght@0,300;0,400;0,600;1,300;1,400&family=IBM+Plex+Mono:wght@400;500;600&family=Syne:wght@400;600;700;800&display=swap" rel="stylesheet">
<style>
  :root {
    --ink: #1a1208;
    --ink-light: #4a3f2f;
    --ink-faint: #7a6e60;
    --paper: #faf7f2;
    --paper-warm: #f3ede3;
    --paper-mid: #e8dfd0;
    --rule: #d4c9b8;
    --rule-dark: #b5a898;
    --red: #c0392b;
    --red-light: #fadbd8;
    --orange: #d35400;
    --orange-light: #fde8d8;
    --green: #1e8449;
    --green-light: #d5f0e0;
    --blue: #1a5276;
    --blue-light: #d6eaf8;
    --amber: #b7950b;
    --amber-light: #fef9e7;
    --purple: #6c3483;
    --purple-light: #f4ecf7;
    --gold: #c9a227;
  }

  * { margin: 0; padding: 0; box-sizing: border-box; }
  html { scroll-behavior: smooth; }

  body {
    background: var(--paper);
    color: var(--ink);
    font-family: 'Crimson Pro', Georgia, serif;
    font-size: 18px;
    line-height: 1.75;
  }

  /* ── MASTHEAD ── */
  .masthead {
    background: var(--ink);
    color: var(--paper);
    position: relative;
    overflow: hidden;
  }
  .masthead::before {
    content: '';
    position: absolute;
    inset: 0;
    background:
      repeating-linear-gradient(0deg, transparent, transparent 39px, rgba(255,255,255,0.03) 39px, rgba(255,255,255,0.03) 40px),
      repeating-linear-gradient(90deg, transparent, transparent 39px, rgba(255,255,255,0.03) 39px, rgba(255,255,255,0.03) 40px);
  }
  .masthead-inner {
    max-width: 1140px;
    margin: 0 auto;
    padding: 3rem 3rem 0;
    position: relative;
  }
  .masthead-meta {
    display: flex;
    justify-content: space-between;
    align-items: center;
    border-bottom: 1px solid rgba(255,255,255,0.15);
    padding-bottom: 1rem;
    margin-bottom: 2rem;
  }
  .masthead-meta span {
    font-family: 'IBM Plex Mono', monospace;
    font-size: 0.7rem;
    letter-spacing: 0.12em;
    text-transform: uppercase;
    opacity: 0.5;
  }
  .issue-badge {
    background: var(--gold);
    color: var(--ink);
    font-family: 'IBM Plex Mono', monospace;
    font-size: 0.65rem;
    font-weight: 600;
    letter-spacing: 0.1em;
    text-transform: uppercase;
    padding: 0.25rem 0.75rem;
    border-radius: 2px;
    opacity: 1 !important;
  }
  .masthead-title {
    display: grid;
    grid-template-columns: 1fr auto;
    gap: 3rem;
    align-items: end;
    padding-bottom: 3rem;
  }
  .masthead-title h1 {
    font-family: 'Playfair Display', serif;
    font-size: clamp(2.6rem, 6vw, 5.2rem);
    font-weight: 900;
    line-height: 0.92;
    letter-spacing: -0.02em;
    color: var(--paper);
  }
  .masthead-title h1 em {
    font-style: italic;
    color: var(--gold);
    display: block;
  }
  .masthead-subtitle {
    max-width: 340px;
    padding-bottom: 0.5rem;
  }
  .masthead-subtitle p {
    font-family: 'Crimson Pro', serif;
    font-size: 1rem;
    line-height: 1.6;
    color: rgba(250,247,242,0.6);
    margin: 0;
  }
  .masthead-subtitle p + p { margin-top: 0.75rem; }
  .masthead-rule {
    height: 6px;
    background: linear-gradient(90deg, var(--gold) 0%, var(--orange) 50%, var(--red) 100%);
  }

  /* ── NAV ── */
  nav {
    background: var(--paper-warm);
    border-bottom: 2px solid var(--ink);
    position: sticky;
    top: 0;
    z-index: 100;
    padding: 0 3rem;
  }
  .nav-inner {
    max-width: 1140px;
    margin: 0 auto;
    display: flex;
    align-items: center;
    overflow-x: auto;
    scrollbar-width: none;
  }
  .nav-inner::-webkit-scrollbar { display: none; }
  nav a {
    font-family: 'Syne', sans-serif;
    font-size: 0.68rem;
    font-weight: 700;
    letter-spacing: 0.1em;
    text-transform: uppercase;
    color: var(--ink-faint);
    text-decoration: none;
    padding: 0.85rem 0.9rem;
    white-space: nowrap;
    border-bottom: 3px solid transparent;
    transition: all 0.15s;
    margin-bottom: -2px;
  }
  nav a:hover { color: var(--ink); border-bottom-color: var(--gold); }

  /* ── LAYOUT ── */
  .page {
    max-width: 1140px;
    margin: 0 auto;
    padding: 4rem 3rem 8rem;
    display: grid;
    grid-template-columns: 220px 1fr;
    gap: 4rem;
    align-items: start;
  }

  /* ── SIDEBAR ── */
  .sidebar {
    position: sticky;
    top: 52px;
    padding-top: 2.5rem;
  }
  .sidebar-title {
    font-family: 'IBM Plex Mono', monospace;
    font-size: 0.65rem;
    font-weight: 600;
    letter-spacing: 0.15em;
    text-transform: uppercase;
    color: var(--ink-faint);
    border-bottom: 1px solid var(--rule);
    padding-bottom: 0.5rem;
    margin-bottom: 1rem;
  }
  .sidebar ol { list-style: none; counter-reset: toc; }
  .sidebar ol li { counter-increment: toc; margin-bottom: 0.1rem; }
  .sidebar ol li a {
    font-family: 'Syne', sans-serif;
    font-size: 0.72rem;
    font-weight: 400;
    color: var(--ink-faint);
    text-decoration: none;
    display: flex;
    gap: 0.5rem;
    align-items: baseline;
    padding: 0.2rem 0;
    border-left: 2px solid transparent;
    padding-left: 0.6rem;
    transition: all 0.15s;
    line-height: 1.3;
  }
  .sidebar ol li a::before {
    content: counter(toc, decimal-leading-zero);
    font-family: 'IBM Plex Mono', monospace;
    font-size: 0.6rem;
    color: var(--rule-dark);
    flex-shrink: 0;
  }
  .sidebar ol li a:hover { color: var(--ink); border-left-color: var(--gold); padding-left: 0.9rem; }
  .sidebar-divider { height: 1px; background: var(--rule); margin: 1.5rem 0; }
  .sidebar-note {
    font-family: 'Crimson Pro', serif;
    font-size: 0.85rem;
    font-style: italic;
    color: var(--ink-faint);
    line-height: 1.5;
  }

  /* ── MAIN CONTENT ── */
  main { min-width: 0; }
  section { margin-bottom: 5rem; scroll-margin-top: 60px; }

  .section-eyebrow { display: flex; align-items: center; gap: 1rem; margin-bottom: 0.75rem; }
  .section-num {
    font-family: 'IBM Plex Mono', monospace;
    font-size: 0.65rem;
    font-weight: 600;
    letter-spacing: 0.12em;
    color: var(--ink-faint);
    background: var(--paper-mid);
    border: 1px solid var(--rule);
    padding: 0.2rem 0.6rem;
    border-radius: 2px;
  }
  .section-tag {
    font-family: 'IBM Plex Mono', monospace;
    font-size: 0.65rem;
    letter-spacing: 0.1em;
    text-transform: uppercase;
    color: var(--ink-faint);
  }

  h2 {
    font-family: 'Playfair Display', serif;
    font-size: 2.4rem;
    font-weight: 700;
    line-height: 1.1;
    letter-spacing: -0.01em;
    color: var(--ink);
    margin-bottom: 0.25rem;
  }
  h2 em { font-style: italic; }

  .section-rule {
    display: flex;
    align-items: center;
    gap: 1rem;
    margin: 1rem 0 2rem;
  }
  .section-rule .line { height: 2px; background: var(--ink); flex: 1; }
  .section-rule .dot { width: 6px; height: 6px; background: var(--gold); border-radius: 50%; }

  h3 {
    font-family: 'Syne', sans-serif;
    font-size: 1rem;
    font-weight: 700;
    letter-spacing: 0.04em;
    text-transform: uppercase;
    color: var(--ink);
    margin-top: 2.5rem;
    margin-bottom: 0.75rem;
  }

  h4 {
    font-family: 'IBM Plex Mono', monospace;
    font-size: 0.75rem;
    font-weight: 600;
    letter-spacing: 0.1em;
    text-transform: uppercase;
    color: var(--ink-faint);
    margin-top: 1.5rem;
    margin-bottom: 0.5rem;
  }

  p { color: var(--ink-light); margin-bottom: 1.2rem; font-size: 1rem; }
  strong { color: var(--ink); font-weight: 600; }

  code {
    font-family: 'IBM Plex Mono', monospace;
    font-size: 0.8em;
    background: var(--paper-mid);
    border: 1px solid var(--rule);
    padding: 0.1em 0.4em;
    border-radius: 2px;
    color: var(--red);
  }

  /* ── CODE BLOCKS ── */
  .code-block {
    margin: 1.75rem 0;
    border: 1px solid var(--rule-dark);
    border-radius: 4px;
    overflow: hidden;
    background: #1e1812;
    box-shadow: 3px 3px 0 var(--rule-dark);
  }
  .code-header {
    background: #2a2118;
    border-bottom: 1px solid #3a3028;
    padding: 0.55rem 1.25rem;
    display: flex;
    justify-content: space-between;
    align-items: center;
  }
  .code-header span {
    font-family: 'IBM Plex Mono', monospace;
    font-size: 0.68rem;
    letter-spacing: 0.08em;
    text-transform: uppercase;
    color: #857060;
  }
  .copy-btn {
    background: transparent;
    border: 1px solid #3a3028;
    color: #857060;
    font-family: 'IBM Plex Mono', monospace;
    font-size: 0.62rem;
    padding: 0.18rem 0.55rem;
    border-radius: 2px;
    cursor: pointer;
    letter-spacing: 0.08em;
    text-transform: uppercase;
    transition: all 0.15s;
  }
  .copy-btn:hover { color: var(--gold); border-color: var(--gold); }
  pre {
    padding: 1.5rem 1.25rem;
    overflow-x: auto;
    font-family: 'IBM Plex Mono', monospace;
    font-size: 0.82rem;
    line-height: 1.75;
    color: #e8dfd0;
  }
  pre code { background: none; border: none; padding: 0; color: inherit; font-size: 1em; }

  /* Syntax highlight classes */
  .kw  { color: #e8956d; }   /* keyword */
  .st  { color: #98c379; }   /* string */
  .cm  { color: #4a4035; font-style: italic; }  /* comment */
  .fn  { color: #c678dd; }   /* function/class name */
  .nm  { color: #e5c07b; }   /* number */
  .op  { color: #c9a227; }   /* operator */
  .at  { color: #7ec8e3; }   /* attribute / variable */
  .dc  { color: #98c379; }   /* decorator / string value */
  .tp  { color: #e8956d; }   /* type */

  /* ── CALLOUTS ── */
  .callout {
    border: 1px solid;
    border-left: 4px solid;
    border-radius: 2px;
    padding: 1.1rem 1.4rem;
    margin: 1.75rem 0;
    font-size: 0.95rem;
  }
  .callout strong {
    font-family: 'IBM Plex Mono', monospace;
    font-size: 0.65rem;
    letter-spacing: 0.12em;
    text-transform: uppercase;
    display: block;
    margin-bottom: 0.4rem;
  }
  .callout p { margin: 0; font-size: 0.9rem; }
  .callout.info    { background: var(--blue-light);   border-color: var(--blue); }
  .callout.info strong { color: var(--blue); }
  .callout.tip     { background: var(--green-light);  border-color: var(--green); }
  .callout.tip strong { color: var(--green); }
  .callout.warning { background: var(--amber-light);  border-color: var(--amber); }
  .callout.warning strong { color: var(--amber); }
  .callout.danger  { background: var(--red-light);    border-color: var(--red); }
  .callout.danger strong { color: var(--red); }
  .callout.purple  { background: var(--purple-light); border-color: var(--purple); }
  .callout.purple strong { color: var(--purple); }

  /* ── TABLES ── */
  .data-table {
    width: 100%;
    border-collapse: collapse;
    font-size: 0.88rem;
    margin: 1.75rem 0;
    border: 1px solid var(--rule-dark);
    box-shadow: 2px 2px 0 var(--rule);
  }
  .data-table th {
    background: var(--ink);
    color: var(--paper-warm);
    padding: 0.7rem 1rem;
    text-align: left;
    font-family: 'Syne', sans-serif;
    font-size: 0.68rem;
    font-weight: 700;
    letter-spacing: 0.1em;
    text-transform: uppercase;
  }
  .data-table td {
    padding: 0.65rem 1rem;
    border-bottom: 1px solid var(--rule);
    color: var(--ink-light);
    vertical-align: top;
  }
  .data-table tr:nth-child(even) td { background: var(--paper-warm); }
  .data-table tr:last-child td { border-bottom: none; }
  .data-table td:first-child {
    font-family: 'IBM Plex Mono', monospace;
    font-size: 0.78rem;
    color: var(--red);
    white-space: nowrap;
  }
  .data-table td code { font-size: 0.75rem; }

  /* ── PULL QUOTE ── */
  .pull-quote {
    border-left: 4px solid var(--gold);
    border-right: 4px solid var(--gold);
    margin: 2.5rem 0;
    padding: 1.5rem 2rem;
    background: var(--amber-light);
    text-align: center;
  }
  .pull-quote p {
    font-family: 'Playfair Display', serif;
    font-size: 1.35rem;
    font-style: italic;
    line-height: 1.4;
    color: var(--ink);
    margin: 0;
  }

  /* ── LEVEL BADGES ── */
  .level-badge {
    display: inline-block;
    font-family: 'IBM Plex Mono', monospace;
    font-size: 0.65rem;
    font-weight: 600;
    padding: 0.2rem 0.6rem;
    border-radius: 2px;
    letter-spacing: 0.08em;
    text-transform: uppercase;
    border: 1px solid;
    margin-left: 0.5rem;
    vertical-align: middle;
  }
  .level-badge.l1 { background: var(--green-light); color: var(--green); border-color: var(--green); }
  .level-badge.l2 { background: var(--blue-light); color: var(--blue); border-color: var(--blue); }
  .level-badge.l3 { background: var(--amber-light); color: var(--amber); border-color: var(--amber); }
  .level-badge.l4 { background: var(--orange-light); color: var(--orange); border-color: var(--orange); }
  .level-badge.l5 { background: var(--red-light); color: var(--red); border-color: var(--red); }

  /* ── CHECKLIST ── */
  .checklist-group {
    border: 1px solid var(--rule-dark);
    padding: 1.25rem 1.5rem;
    margin: 1rem 0;
    background: white;
    box-shadow: 2px 2px 0 var(--rule);
  }
  .checklist-group h4 {
    font-family: 'Syne', sans-serif;
    font-size: 0.72rem;
    font-weight: 700;
    text-transform: uppercase;
    letter-spacing: 0.1em;
    color: var(--ink);
    margin-bottom: 0.75rem;
    margin-top: 0;
    padding-bottom: 0.5rem;
    border-bottom: 1px solid var(--rule);
  }
  .checklist { list-style: none; }
  .checklist li {
    padding: 0.45rem 0;
    border-bottom: 1px solid var(--paper-warm);
    font-size: 0.9rem;
    color: var(--ink-faint);
    display: flex;
    align-items: flex-start;
    gap: 0.75rem;
    font-family: 'IBM Plex Mono', monospace;
    font-size: 0.82rem;
  }
  .checklist li:last-child { border-bottom: none; }
  .checklist li::before { content: '→'; color: var(--gold); flex-shrink: 0; }

  /* ── FOOTER ── */
  footer {
    background: var(--ink);
    color: var(--paper-warm);
    padding: 2.5rem 3rem;
    text-align: center;
  }
  footer p {
    font-family: 'IBM Plex Mono', monospace;
    font-size: 0.7rem;
    letter-spacing: 0.08em;
    color: rgba(250,247,242,0.5);
    margin: 0;
  }
  footer p + p { margin-top: 0.4rem; }

  /* ── RESPONSIVE ── */
  @media (max-width: 900px) {
    .page { grid-template-columns: 1fr; padding: 2rem 1.5rem 6rem; }
    .sidebar { position: static; display: none; }
    .masthead-inner { padding: 2rem 1.5rem 0; }
    .masthead-title { grid-template-columns: 1fr; gap: 1.5rem; }
    nav { padding: 0 1.5rem; }
  }

  /* ── ANIMATIONS ── */
  @keyframes fadeUp {
    from { opacity: 0; transform: translateY(16px); }
    to   { opacity: 1; transform: translateY(0); }
  }
  .masthead-title h1 { animation: fadeUp 0.6s ease both; }
  .masthead-subtitle { animation: fadeUp 0.6s 0.1s ease both; }
  section { animation: fadeUp 0.5s ease both; }
</style>
</head>
<body>

<!-- MASTHEAD -->
<div class="masthead">
  <div class="masthead-inner">
    <div class="masthead-meta">
      <span>Complete Reference · Production Grade</span>
      <span class="issue-badge">Beginner → Legend</span>
      <span>Django ORM</span>
    </div>
    <div class="masthead-title">
      <h1>The Ultimate<br>Django<em>Querying Guide</em></h1>
      <div class="masthead-subtitle">
        <p>Dense, comprehensive, production-grade. Every ORM pattern you will encounter — from beginner CRUD to window functions, locking, and the heavily nested dashboard query.</p>
        <p>Built around a realistic accounting system schema used throughout every example.</p>
      </div>
    </div>
  </div>
  <div class="masthead-rule"></div>
</div>

<!-- NAV -->
<nav>
  <div class="nav-inner">
    <a href="#schema">Schema</a>
    <a href="#basics">Basics</a>
    <a href="#filtering">Filtering</a>
    <a href="#ordering">Ordering</a>
    <a href="#relationships">Relationships</a>
    <a href="#qobjects">Q Objects</a>
    <a href="#managers">Managers</a>
    <a href="#aggregations">Aggregations</a>
    <a href="#annotations">Annotations</a>
    <a href="#subqueries">Subqueries</a>
    <a href="#bulk">Bulk Ops</a>
    <a href="#windows">Windows</a>
    <a href="#rawsql">Raw SQL</a>
    <a href="#optimization">Optimization</a>
    <a href="#locking">Locking</a>
    <a href="#transactions">Transactions</a>
    <a href="#indexes">Indexes</a>
    <a href="#nested">Nested Example</a>
    <a href="#checklist">Checklist</a>
    <a href="#cheatsheet">Cheat Sheet</a>
  </div>
</nav>

<!-- PAGE -->
<div class="page">

  <!-- SIDEBAR -->
  <aside class="sidebar">
    <div class="sidebar-title">Contents</div>
    <ol>
      <li><a href="#schema">The Data Model</a></li>
      <li><a href="#basics">QuerySet Basics & CRUD</a></li>
      <li><a href="#filtering">Filtering Lookups</a></li>
      <li><a href="#ordering">Ordering & Slicing</a></li>
      <li><a href="#relationships">select_related</a></li>
      <li><a href="#prefetch">prefetch_related</a></li>
      <li><a href="#joins">Filtering Across Joins</a></li>
      <li><a href="#qobjects">Q Objects</a></li>
      <li><a href="#managers">Custom QuerySets</a></li>
      <li><a href="#aggregations">aggregate()</a></li>
      <li><a href="#annotations">annotate()</a></li>
      <li><a href="#groupby">values() + GROUP BY</a></li>
      <li><a href="#casewhen">Case / When</a></li>
      <li><a href="#subqueries">Subqueries & OuterRef</a></li>
      <li><a href="#bulk">Bulk Operations</a></li>
      <li><a href="#windows">Window Functions</a></li>
      <li><a href="#rawsql">Raw SQL</a></li>
      <li><a href="#inspecting">Inspecting Queries</a></li>
      <li><a href="#optimization">only() & defer()</a></li>
      <li><a href="#iterator">iterator()</a></li>
      <li><a href="#locking">select_for_update()</a></li>
      <li><a href="#transactions">Transactions</a></li>
      <li><a href="#indexes">Indexes</a></li>
      <li><a href="#nested">The Nested Example</a></li>
      <li><a href="#checklist">N+1 Checklist</a></li>
      <li><a href="#cheatsheet">Cheat Sheet</a></li>
    </ol>
    <div class="sidebar-divider"></div>
    <p class="sidebar-note">Every example uses the accounting schema defined in §1. Master select_related and prefetch_related first — they account for 80% of real performance problems.</p>
  </aside>

  <!-- MAIN -->
  <main>

    <!-- §1 SCHEMA -->
    <section id="schema">
      <div class="section-eyebrow"><span class="section-num">§ 01</span><span class="section-tag">Foundation</span></div>
      <h2>The Data <em>Model</em></h2>
      <div class="section-rule"><div class="line"></div><div class="dot"></div><div class="line" style="max-width:60px"></div></div>

      <p>Everything in this guide is grounded in a realistic accounting system. Understanding the schema first makes every example below immediately applicable to real work.</p>

      <div class="code-block">
        <div class="code-header"><span>models.py — full schema</span><button class="copy-btn" onclick="copyCode(this)">Copy</button></div>
        <pre><code><span class="kw">from</span> django.db <span class="kw">import</span> models
<span class="kw">from</span> django.contrib.auth <span class="kw">import</span> get_user_model

<span class="at">User</span> = get_user_model()


<span class="kw">class</span> <span class="fn">TimestampedModel</span>(models.Model):
    <span class="st">"""Abstract base — every model gets created_at / updated_at automatically."""</span>
    <span class="at">created_at</span> = models.DateTimeField(auto_now_add=<span class="kw">True</span>)
    <span class="at">updated_at</span> = models.DateTimeField(auto_now=<span class="kw">True</span>)

    <span class="kw">class</span> <span class="fn">Meta</span>:
        <span class="at">abstract</span> = <span class="kw">True</span>


<span class="kw">class</span> <span class="fn">Company</span>(<span class="fn">TimestampedModel</span>):
    <span class="at">name</span> = models.CharField(max_length=<span class="nm">255</span>)
    <span class="at">tax_id</span> = models.CharField(max_length=<span class="nm">50</span>, unique=<span class="kw">True</span>)
    <span class="at">fiscal_year_start</span> = models.IntegerField(default=<span class="nm">1</span>)
    <span class="at">currency</span> = models.CharField(max_length=<span class="nm">3</span>, default=<span class="st">"USD"</span>)
    <span class="at">is_active</span> = models.BooleanField(default=<span class="kw">True</span>)

    <span class="kw">class</span> <span class="fn">Meta</span>:
        <span class="at">verbose_name_plural</span> = <span class="st">"companies"</span>


<span class="kw">class</span> <span class="fn">CostCenter</span>(<span class="fn">TimestampedModel</span>):
    <span class="at">company</span> = models.ForeignKey(<span class="fn">Company</span>, on_delete=models.CASCADE, related_name=<span class="st">"cost_centers"</span>)
    <span class="at">name</span> = models.CharField(max_length=<span class="nm">100</span>)
    <span class="at">code</span> = models.CharField(max_length=<span class="nm">20</span>)
    <span class="at">parent</span> = models.ForeignKey(
        <span class="st">"self"</span>, null=<span class="kw">True</span>, blank=<span class="kw">True</span>, on_delete=models.SET_NULL, related_name=<span class="st">"children"</span>
    )
    <span class="kw">class</span> <span class="fn">Meta</span>:
        <span class="at">unique_together</span> = [(<span class="st">"company"</span>, <span class="st">"code"</span>)]


<span class="kw">class</span> <span class="fn">ChartOfAccount</span>(<span class="fn">TimestampedModel</span>):
    <span class="at">ACCOUNT_TYPES</span> = [(<span class="st">"asset"</span>,<span class="st">"Asset"</span>),(<span class="st">"liability"</span>,<span class="st">"Liability"</span>),(<span class="st">"equity"</span>,<span class="st">"Equity"</span>),(<span class="st">"revenue"</span>,<span class="st">"Revenue"</span>),(<span class="st">"expense"</span>,<span class="st">"Expense"</span>)]
    <span class="at">company</span> = models.ForeignKey(<span class="fn">Company</span>, on_delete=models.CASCADE, related_name=<span class="st">"accounts"</span>)
    <span class="at">code</span> = models.CharField(max_length=<span class="nm">20</span>)
    <span class="at">name</span> = models.CharField(max_length=<span class="nm">255</span>)
    <span class="at">account_type</span> = models.CharField(max_length=<span class="nm">20</span>, choices=<span class="at">ACCOUNT_TYPES</span>)
    <span class="at">parent</span> = models.ForeignKey(<span class="st">"self"</span>, null=<span class="kw">True</span>, blank=<span class="kw">True</span>, on_delete=models.SET_NULL, related_name=<span class="st">"children"</span>)
    <span class="at">is_active</span> = models.BooleanField(default=<span class="kw">True</span>)
    <span class="kw">class</span> <span class="fn">Meta</span>:
        <span class="at">unique_together</span> = [(<span class="st">"company"</span>, <span class="st">"code"</span>)]
        <span class="at">indexes</span> = [models.Index(fields=[<span class="st">"company"</span>, <span class="st">"account_type"</span>], name=<span class="st">"coa_company_type_idx"</span>)]


<span class="kw">class</span> <span class="fn">JournalEntry</span>(<span class="fn">TimestampedModel</span>):
    <span class="at">STATUS_CHOICES</span> = [(<span class="st">"draft"</span>,<span class="st">"Draft"</span>),(<span class="st">"posted"</span>,<span class="st">"Posted"</span>),(<span class="st">"voided"</span>,<span class="st">"Voided"</span>)]
    <span class="at">company</span> = models.ForeignKey(<span class="fn">Company</span>, on_delete=models.PROTECT, related_name=<span class="st">"journal_entries"</span>)
    <span class="at">date</span> = models.DateField()
    <span class="at">reference</span> = models.CharField(max_length=<span class="nm">100</span>, blank=<span class="kw">True</span>)
    <span class="at">description</span> = models.TextField(blank=<span class="kw">True</span>)
    <span class="at">status</span> = models.CharField(max_length=<span class="nm">20</span>, choices=<span class="at">STATUS_CHOICES</span>, default=<span class="st">"draft"</span>)
    <span class="at">created_by</span> = models.ForeignKey(<span class="fn">User</span>, on_delete=models.PROTECT, related_name=<span class="st">"created_entries"</span>)
    <span class="at">approved_by</span> = models.ForeignKey(<span class="fn">User</span>, null=<span class="kw">True</span>, blank=<span class="kw">True</span>, on_delete=models.SET_NULL, related_name=<span class="st">"approved_entries"</span>)
    <span class="at">approved_at</span> = models.DateTimeField(null=<span class="kw">True</span>, blank=<span class="kw">True</span>)
    <span class="kw">class</span> <span class="fn">Meta</span>:
        <span class="at">indexes</span> = [
            models.Index(fields=[<span class="st">"company"</span>, <span class="st">"date"</span>], name=<span class="st">"je_company_date_idx"</span>),
            models.Index(fields=[<span class="st">"company"</span>, <span class="st">"date"</span>], condition=models.Q(status=<span class="st">"posted"</span>), name=<span class="st">"je_company_date_posted_idx"</span>),
            models.Index(fields=[<span class="st">"company"</span>, <span class="st">"status"</span>], name=<span class="st">"je_company_status_idx"</span>),
        ]


<span class="kw">class</span> <span class="fn">JournalEntryLine</span>(<span class="fn">TimestampedModel</span>):
    <span class="at">journal_entry</span> = models.ForeignKey(<span class="fn">JournalEntry</span>, on_delete=models.CASCADE, related_name=<span class="st">"lines"</span>)
    <span class="at">coa_account</span> = models.ForeignKey(<span class="fn">ChartOfAccount</span>, on_delete=models.PROTECT, related_name=<span class="st">"entry_lines"</span>)
    <span class="at">debit</span> = models.DecimalField(max_digits=<span class="nm">18</span>, decimal_places=<span class="nm">2</span>, default=<span class="nm">0</span>)
    <span class="at">credit</span> = models.DecimalField(max_digits=<span class="nm">18</span>, decimal_places=<span class="nm">2</span>, default=<span class="nm">0</span>)
    <span class="at">cost_center</span> = models.ForeignKey(<span class="fn">CostCenter</span>, on_delete=models.PROTECT, null=<span class="kw">True</span>, blank=<span class="kw">True</span>, related_name=<span class="st">"lines"</span>)
    <span class="at">description</span> = models.TextField(blank=<span class="kw">True</span>)
    <span class="kw">class</span> <span class="fn">Meta</span>:
        <span class="at">constraints</span> = [
            models.CheckConstraint(check=<span class="op">~</span>(models.Q(debit__gt=<span class="nm">0</span>) <span class="op">&</span> models.Q(credit__gt=<span class="nm">0</span>)), name=<span class="st">"no_simultaneous_debit_and_credit"</span>),
            models.CheckConstraint(check=models.Q(debit__gte=<span class="nm">0</span>) <span class="op">&</span> models.Q(credit__gte=<span class="nm">0</span>), name=<span class="st">"non_negative_amounts"</span>),
        ]


<span class="kw">class</span> <span class="fn">Budget</span>(<span class="fn">TimestampedModel</span>):
    <span class="at">company</span> = models.ForeignKey(<span class="fn">Company</span>, on_delete=models.CASCADE, related_name=<span class="st">"budgets"</span>)
    <span class="at">coa_account</span> = models.ForeignKey(<span class="fn">ChartOfAccount</span>, on_delete=models.PROTECT)
    <span class="at">cost_center</span> = models.ForeignKey(<span class="fn">CostCenter</span>, null=<span class="kw">True</span>, blank=<span class="kw">True</span>, on_delete=models.SET_NULL)
    <span class="at">year</span> = models.IntegerField()
    <span class="at">month</span> = models.IntegerField()
    <span class="at">amount</span> = models.DecimalField(max_digits=<span class="nm">18</span>, decimal_places=<span class="nm">2</span>)
    <span class="kw">class</span> <span class="fn">Meta</span>:
        <span class="at">unique_together</span> = [(<span class="st">"company"</span>, <span class="st">"coa_account"</span>, <span class="st">"cost_center"</span>, <span class="st">"year"</span>, <span class="st">"month"</span>)]</code></pre>
      </div>
    </section>

    <!-- §2 BASICS -->
    <section id="basics">
      <div class="section-eyebrow"><span class="section-num">§ 02</span><span class="section-tag">Level 1 — Beginner</span></div>
      <h2>QuerySet Basics <em>&amp; CRUD</em></h2>
      <div class="section-rule"><div class="line"></div><div class="dot"></div><div class="line" style="max-width:60px"></div></div>

      <p>A QuerySet is <strong>lazy</strong> — it does not hit the database until you force evaluation. Django builds up a SQL query in Python and only executes it when you iterate, slice, call <code>list()</code>, <code>bool()</code>, <code>len()</code>, or <code>repr()</code> on it.</p>

      <div class="code-block">
        <div class="code-header"><span>Python — lazy evaluation</span><button class="copy-btn" onclick="copyCode(this)">Copy</button></div>
        <pre><code><span class="cm"># This does NOT hit the database — just builds a query object</span>
<span class="at">qs</span> = JournalEntry.objects.filter(status=<span class="st">"posted"</span>)

<span class="cm"># Still no DB hit — another filter is appended to the SQL</span>
<span class="at">qs</span> = qs.filter(company=company)

<span class="cm"># THIS hits the database — evaluation is forced</span>
<span class="at">entries</span> = list(qs)

<span class="cm"># These also force evaluation:</span>
<span class="kw">for</span> entry <span class="kw">in</span> qs: ...    <span class="cm"># iteration</span>
<span class="kw">if</span> qs.exists(): ...       <span class="cm"># exists()</span>
<span class="at">count</span> = qs.count()        <span class="cm"># count()</span></code></pre>
      </div>

      <h3>Basic CRUD</h3>
      <div class="code-block">
        <div class="code-header"><span>Python — CRUD operations</span><button class="copy-btn" onclick="copyCode(this)">Copy</button></div>
        <pre><code><span class="cm"># CREATE — one INSERT</span>
<span class="at">entry</span> = JournalEntry.objects.create(
    company=company, date=<span class="st">"2024-01-15"</span>, description=<span class="st">"Opening balance"</span>,
    status=<span class="st">"draft"</span>, created_by=request.user,
)

<span class="cm"># Alternative: instantiate then save (runs validation before saving)</span>
<span class="at">entry</span> = JournalEntry(company=company, date=<span class="st">"2024-01-15"</span>, created_by=request.user)
entry.full_clean()
entry.save()

<span class="cm"># READ ONE — raises DoesNotExist if not found, MultipleObjectsReturned if >1</span>
JournalEntry.objects.get(id=<span class="nm">1</span>)

<span class="cm"># READ ONE SAFELY — returns None instead of raising</span>
JournalEntry.objects.filter(id=<span class="nm">1</span>).first()

<span class="cm"># get_or_create — returns (instance, created_bool)</span>
<span class="at">entry</span>, <span class="at">created</span> = JournalEntry.objects.get_or_create(
    company=company, reference=<span class="st">"INV-2024-001"</span>,
    defaults={<span class="st">"date"</span>: <span class="st">"2024-01-15"</span>, <span class="st">"created_by"</span>: request.user},
)

<span class="cm"># UPDATE — one UPDATE statement. Does NOT call .save() or trigger signals</span>
JournalEntry.objects.filter(id=<span class="nm">1</span>).update(description=<span class="st">"Updated"</span>, status=<span class="st">"posted"</span>)

<span class="cm"># DELETE — one DELETE statement</span>
JournalEntry.objects.filter(status=<span class="st">"voided"</span>).delete()

<span class="cm"># Existence & counting — use these, never len(qs)</span>
JournalEntry.objects.filter(status=<span class="st">"posted"</span>).exists()   <span class="cm"># → True/False, SELECT 1 LIMIT 1</span>
JournalEntry.objects.filter(status=<span class="st">"posted"</span>).count()    <span class="cm"># → int, SELECT COUNT(*)</span></code></pre>
      </div>
    </section>

    <!-- §3 FILTERING -->
    <section id="filtering">
      <div class="section-eyebrow"><span class="section-num">§ 03</span><span class="section-tag">Level 1 — Beginner</span></div>
      <h2>Filtering — Every <em>Lookup Type</em></h2>
      <div class="section-rule"><div class="line"></div><div class="dot"></div><div class="line" style="max-width:60px"></div></div>

      <p>Django lookup types are appended to field names with double underscores. They translate directly to SQL operators.</p>

      <div class="code-block">
        <div class="code-header"><span>Python — all lookup types</span><button class="copy-btn" onclick="copyCode(this)">Copy</button></div>
        <pre><code><span class="cm"># Exact (default — __exact is implicit)</span>
JournalEntry.objects.filter(status=<span class="st">"posted"</span>)

<span class="cm"># String lookups</span>
JournalEntry.objects.filter(description__contains=<span class="st">"rent"</span>)       <span class="cm"># LIKE '%rent%'</span>
JournalEntry.objects.filter(description__icontains=<span class="st">"rent"</span>)      <span class="cm"># ILIKE (case-insensitive)</span>
JournalEntry.objects.filter(reference__startswith=<span class="st">"INV"</span>)        <span class="cm"># LIKE 'INV%'</span>
JournalEntry.objects.filter(reference__endswith=<span class="st">"2024"</span>)         <span class="cm"># LIKE '%2024'</span>
JournalEntry.objects.filter(description__regex=<span class="st">r"^[A-Z]{3}"</span>)   <span class="cm"># regex</span>
JournalEntry.objects.filter(description__iregex=<span class="st">r"^[a-z]{3}"</span>)  <span class="cm"># case-insensitive regex</span>

<span class="cm"># Numeric comparisons</span>
JournalEntryLine.objects.filter(debit__gt=<span class="nm">0</span>)         <span class="cm"># ></span>
JournalEntryLine.objects.filter(debit__gte=<span class="nm">1000</span>)     <span class="cm"># >=</span>
JournalEntryLine.objects.filter(credit__lt=<span class="nm">5000</span>)     <span class="cm"># <</span>
JournalEntryLine.objects.filter(credit__lte=<span class="nm">4999.99</span>) <span class="cm"># <=</span>

<span class="cm"># Range (inclusive on both ends → BETWEEN)</span>
JournalEntry.objects.filter(date__range=(<span class="st">"2024-01-01"</span>, <span class="st">"2024-12-31"</span>))

<span class="cm"># In a list</span>
JournalEntry.objects.filter(status__in=[<span class="st">"posted"</span>, <span class="st">"draft"</span>])

<span class="cm"># Null checks</span>
JournalEntry.objects.filter(approved_by__isnull=<span class="kw">True</span>)
JournalEntry.objects.filter(approved_by__isnull=<span class="kw">False</span>)

<span class="cm"># Date/time component extraction</span>
JournalEntry.objects.filter(date__year=<span class="nm">2024</span>)
JournalEntry.objects.filter(date__month=<span class="nm">3</span>)
JournalEntry.objects.filter(date__quarter=<span class="nm">1</span>)
JournalEntry.objects.filter(date__week=<span class="nm">12</span>)
JournalEntry.objects.filter(created_at__hour=<span class="nm">9</span>)
JournalEntry.objects.filter(created_at__date=<span class="st">"2024-01-15"</span>)

<span class="cm"># Exclude — NOT (inverts the filter)</span>
JournalEntry.objects.exclude(status=<span class="st">"voided"</span>)

<span class="cm"># Chaining (each .filter() is an AND)</span>
JournalEntry.objects.filter(status=<span class="st">"posted"</span>, company=company, date__year=<span class="nm">2024</span>)</code></pre>
      </div>
    </section>

    <!-- §4 ORDERING -->
    <section id="ordering">
      <div class="section-eyebrow"><span class="section-num">§ 04</span><span class="section-tag">Level 1 — Beginner</span></div>
      <h2>Ordering <em>&amp; Slicing</em></h2>
      <div class="section-rule"><div class="line"></div><div class="dot"></div><div class="line" style="max-width:60px"></div></div>

      <div class="code-block">
        <div class="code-header"><span>Python — ordering & slicing</span><button class="copy-btn" onclick="copyCode(this)">Copy</button></div>
        <pre><code>JournalEntry.objects.order_by(<span class="st">"date"</span>)              <span class="cm"># ascending</span>
JournalEntry.objects.order_by(<span class="st">"-date"</span>)             <span class="cm"># descending</span>
JournalEntry.objects.order_by(<span class="st">"-date"</span>, <span class="st">"reference"</span>) <span class="cm"># secondary sort on tie</span>
JournalEntry.objects.order_by(<span class="st">"company__name"</span>, <span class="st">"-date"</span>)  <span class="cm"># related field</span>
JournalEntry.objects.all().order_by()              <span class="cm"># clear inherited ordering</span>

<span class="cm"># Slicing → LIMIT/OFFSET. Negative indexing NOT supported.</span>
JournalEntry.objects.all()[:<span class="nm">10</span>]       <span class="cm"># LIMIT 10</span>
JournalEntry.objects.all()[<span class="nm">10</span>:<span class="nm">20</span>]     <span class="cm"># LIMIT 10 OFFSET 10</span>

<span class="cm"># You cannot filter after slicing — raises TypeError</span>
<span class="cm"># JournalEntry.objects.all()[:10].filter(status="posted")  ← WRONG</span></code></pre>
      </div>
    </section>

    <!-- §5 RELATIONSHIPS -->
    <section id="relationships">
      <div class="section-eyebrow"><span class="section-num">§ 05</span><span class="section-tag">Level 2 — Intermediate</span></div>
      <h2>select_related — <em>Eliminating N+1</em></h2>
      <div class="section-rule"><div class="line"></div><div class="dot"></div><div class="line" style="max-width:60px"></div></div>

      <p><code>select_related</code> works by performing a SQL JOIN and selecting the related object's columns in the same query. Use it for <code>ForeignKey</code> and <code>OneToOneField</code>. Without it, accessing <code>entry.company</code> on each object in a loop causes one extra query per row — the N+1 problem.</p>

      <div class="callout danger">
        <strong>The N+1 Problem</strong>
        <p>1 query to get entries, then 1 per entry to get company = N+1 queries total. With 500 entries, that's 501 database hits. Always use <code>select_related</code> for FK fields you'll access in a loop.</p>
      </div>

      <div class="code-block">
        <div class="code-header"><span>Python — select_related</span><button class="copy-btn" onclick="copyCode(this)">Copy</button></div>
        <pre><code><span class="cm"># BAD — N+1 problem</span>
<span class="at">entries</span> = JournalEntry.objects.filter(status=<span class="st">"posted"</span>)
<span class="kw">for</span> entry <span class="kw">in</span> entries:
    print(entry.company.name)   <span class="cm"># hits DB every iteration</span>

<span class="cm"># GOOD — 1 query with JOIN</span>
<span class="at">entries</span> = JournalEntry.objects.select_related(<span class="st">"company"</span>).filter(status=<span class="st">"posted"</span>)
<span class="kw">for</span> entry <span class="kw">in</span> entries:
    print(entry.company.name)   <span class="cm"># no extra query</span>

<span class="cm"># Multiple FK relationships</span>
JournalEntry.objects.select_related(<span class="st">"company"</span>, <span class="st">"created_by"</span>, <span class="st">"approved_by"</span>)

<span class="cm"># Traverse deeper — follow FKs on FKs</span>
JournalEntry.objects.select_related(<span class="st">"company"</span>, <span class="st">"created_by__profile"</span>)

<span class="cm"># Nested deeper — CostCenter has self-referential parent FK</span>
JournalEntryLine.objects.select_related(
    <span class="st">"journal_entry__company"</span>,
    <span class="st">"coa_account"</span>,
    <span class="st">"cost_center__parent"</span>,
)</code></pre>
      </div>
    </section>

    <!-- §6 PREFETCH -->
    <section id="prefetch">
      <div class="section-eyebrow"><span class="section-num">§ 06</span><span class="section-tag">Level 2 — Intermediate</span></div>
      <h2>prefetch_related — <em>Reverse FK &amp; M2M</em></h2>
      <div class="section-rule"><div class="line"></div><div class="dot"></div><div class="line" style="max-width:60px"></div></div>

      <p><code>prefetch_related</code> executes a <strong>separate</strong> query for the related objects and stitches the results together in Python. Use it for reverse FK (one-to-many) and M2M. It avoids N+1 with 2 queries total instead of a JOIN.</p>

      <div class="code-block">
        <div class="code-header"><span>Python — prefetch_related</span><button class="copy-btn" onclick="copyCode(this)">Copy</button></div>
        <pre><code><span class="kw">from</span> django.db.models <span class="kw">import</span> Prefetch

<span class="cm"># Basic — fetches all lines in a single separate query</span>
JournalEntry.objects.prefetch_related(<span class="st">"lines"</span>)

<span class="cm"># With Prefetch() — customize the queryset for the related objects</span>
JournalEntry.objects.prefetch_related(
    Prefetch(
        <span class="st">"lines"</span>,
        queryset=JournalEntryLine.objects.select_related(<span class="st">"coa_account"</span>, <span class="st">"cost_center"</span>)
    )
)
<span class="cm"># Result: exactly 2 DB queries regardless of how many JournalEntries are returned</span>

<span class="cm"># Prefetch with filtering + to_attr (stores as a plain list on the instance)</span>
JournalEntry.objects.prefetch_related(
    Prefetch(
        <span class="st">"lines"</span>,
        queryset=JournalEntryLine.objects.filter(debit__gt=<span class="nm">0</span>).select_related(<span class="st">"coa_account"</span>),
        to_attr=<span class="st">"debit_lines"</span>,  <span class="cm"># access as entry.debit_lines (list, not queryset)</span>
    )
)

<span class="cm"># Prefetch on self-referential FK (active children of each account)</span>
ChartOfAccount.objects.prefetch_related(
    Prefetch(<span class="st">"children"</span>, queryset=ChartOfAccount.objects.filter(is_active=<span class="kw">True</span>))
)</code></pre>
      </div>
    </section>

    <!-- §7 JOINS -->
    <section id="joins">
      <div class="section-eyebrow"><span class="section-num">§ 07</span><span class="section-tag">Level 2 — Intermediate</span></div>
      <h2>Filtering Across <em>Relationships</em></h2>
      <div class="section-rule"><div class="line"></div><div class="dot"></div><div class="line" style="max-width:60px"></div></div>

      <div class="callout warning">
        <strong>The chained .filter() subtlety — one of the most common query bugs</strong>
        <p>For multi-valued relations (reverse FK, M2M), chaining two <code>.filter()</code> calls vs putting both conditions in the same <code>.filter()</code> produces <strong>different SQL</strong>.</p>
      </div>

      <div class="code-block">
        <div class="code-header"><span>Python — filter across relationships</span><button class="copy-btn" onclick="copyCode(this)">Copy</button></div>
        <pre><code><span class="cm"># Forward FK — implicit JOIN</span>
JournalEntry.objects.filter(company__name__icontains=<span class="st">"Acme"</span>)

<span class="cm"># Multi-level traversal</span>
JournalEntry.objects.filter(lines__coa_account__account_type=<span class="st">"expense"</span>)

<span class="cm"># Without distinct(), an entry with 3 qualifying lines appears 3 times</span>
JournalEntry.objects.filter(lines__debit__gt=<span class="nm">0</span>).distinct()

<span class="cm"># Version A: finds entries where a SINGLE line has debit > 0 AND credit == 0</span>
JournalEntry.objects.filter(lines__debit__gt=<span class="nm">0</span>, lines__credit=<span class="nm">0</span>)

<span class="cm"># Version B: finds entries where (some line has debit > 0) AND (some other line has credit == 0)</span>
JournalEntry.objects.filter(lines__debit__gt=<span class="nm">0</span>).filter(lines__credit=<span class="nm">0</span>)</code></pre>
      </div>
    </section>

    <!-- §8 Q OBJECTS -->
    <section id="qobjects">
      <div class="section-eyebrow"><span class="section-num">§ 08</span><span class="section-tag">Level 2 — Intermediate</span></div>
      <h2>Q Objects — <em>Arbitrary Boolean Logic</em></h2>
      <div class="section-rule"><div class="line"></div><div class="dot"></div><div class="line" style="max-width:60px"></div></div>

      <p><code>Q</code> objects wrap filter conditions and can be composed with <code>|</code> (OR), <code>&amp;</code> (AND), and <code>~</code> (NOT). Without Q objects you're limited to AND-only filters.</p>

      <div class="code-block">
        <div class="code-header"><span>Python — Q objects</span><button class="copy-btn" onclick="copyCode(this)">Copy</button></div>
        <pre><code><span class="kw">from</span> django.db.models <span class="kw">import</span> Q

<span class="cm"># OR</span>
JournalEntry.objects.filter(Q(status=<span class="st">"posted"</span>) | Q(reference__startswith=<span class="st">"INV"</span>))

<span class="cm"># NOT</span>
JournalEntry.objects.filter(<span class="op">~</span>Q(status=<span class="st">"voided"</span>))

<span class="cm"># Combine NOT with OR</span>
JournalEntry.objects.filter(<span class="op">~</span>Q(status=<span class="st">"voided"</span>) <span class="op">&</span> (Q(company=company) | Q(reference__startswith=<span class="st">"INV"</span>)))

<span class="cm"># Dynamic filter construction — build up Q objects programmatically</span>
<span class="kw">def</span> <span class="fn">search_entries</span>(company, status=<span class="kw">None</span>, date_from=<span class="kw">None</span>, date_to=<span class="kw">None</span>, search_term=<span class="kw">None</span>):
    <span class="at">filters</span> = Q(company=company)

    <span class="kw">if</span> status:
        <span class="at">filters</span> <span class="op">&=</span> Q(status=status)
    <span class="kw">if</span> date_from:
        <span class="at">filters</span> <span class="op">&=</span> Q(date__gte=date_from)
    <span class="kw">if</span> date_to:
        <span class="at">filters</span> <span class="op">&=</span> Q(date__lte=date_to)
    <span class="kw">if</span> search_term:
        <span class="at">filters</span> <span class="op">&=</span> (
            Q(description__icontains=search_term) |
            Q(reference__icontains=search_term) |
            Q(lines__description__icontains=search_term)
        )

    <span class="kw">return</span> JournalEntry.objects.filter(filters).distinct()</code></pre>
      </div>
    </section>

    <!-- §9 MANAGERS -->
    <section id="managers">
      <div class="section-eyebrow"><span class="section-num">§ 09</span><span class="section-tag">Level 2 — Intermediate</span></div>
      <h2>Custom QuerySets <em>&amp; Managers</em></h2>
      <div class="section-rule"><div class="line"></div><div class="dot"></div><div class="line" style="max-width:60px"></div></div>

      <p>Scattering <code>.filter(status="posted")</code> across 20 views is a maintenance nightmare. Custom QuerySets centralize this logic, make it reusable, and make your code read like English.</p>

      <div class="code-block">
        <div class="code-header"><span>Python — custom QuerySet & Manager</span><button class="copy-btn" onclick="copyCode(this)">Copy</button></div>
        <pre><code><span class="kw">from</span> django.db.models <span class="kw">import</span> Prefetch, Sum, Count, Q


<span class="kw">class</span> <span class="fn">JournalEntryQuerySet</span>(models.QuerySet):
    <span class="kw">def</span> <span class="fn">posted</span>(self): <span class="kw">return</span> self.filter(status=<span class="st">"posted"</span>)
    <span class="kw">def</span> <span class="fn">draft</span>(self): <span class="kw">return</span> self.filter(status=<span class="st">"draft"</span>)
    <span class="kw">def</span> <span class="fn">for_company</span>(self, company): <span class="kw">return</span> self.filter(company=company)
    <span class="kw">def</span> <span class="fn">in_period</span>(self, date_from, date_to): <span class="kw">return</span> self.filter(date__range=(date_from, date_to))
    <span class="kw">def</span> <span class="fn">in_year</span>(self, year): <span class="kw">return</span> self.filter(date__year=year)

    <span class="kw">def</span> <span class="fn">unbalanced</span>(self):
        <span class="st">"""Entries where total debits != total credits."""</span>
        <span class="kw">return</span> self.annotate(
            total_debit=Sum(<span class="st">"lines__debit"</span>),
            total_credit=Sum(<span class="st">"lines__credit"</span>),
        ).exclude(total_debit=models.F(<span class="st">"total_credit"</span>))

    <span class="kw">def</span> <span class="fn">with_lines</span>(self):
        <span class="st">"""Eagerly load lines and their FKs — use whenever serializing."""</span>
        <span class="kw">return</span> self.prefetch_related(
            Prefetch(<span class="st">"lines"</span>, queryset=JournalEntryLine.objects.select_related(
                <span class="st">"coa_account"</span>, <span class="st">"cost_center"</span>
            ).order_by(<span class="st">"id"</span>))
        )

    <span class="kw">def</span> <span class="fn">with_totals</span>(self):
        <span class="kw">return</span> self.annotate(
            total_debit=Sum(<span class="st">"lines__debit"</span>),
            total_credit=Sum(<span class="st">"lines__credit"</span>),
            line_count=Count(<span class="st">"lines"</span>),
        )

    <span class="kw">def</span> <span class="fn">search</span>(self, term):
        <span class="kw">return</span> self.filter(Q(description__icontains=term) | Q(reference__icontains=term))


<span class="kw">class</span> <span class="fn">JournalEntryManager</span>(models.Manager):
    <span class="kw">def</span> <span class="fn">get_queryset</span>(self): <span class="kw">return</span> JournalEntryQuerySet(self.model, using=self._db)
    <span class="kw">def</span> <span class="fn">posted</span>(self): <span class="kw">return</span> self.get_queryset().posted()
    <span class="kw">def</span> <span class="fn">for_company</span>(self, company): <span class="kw">return</span> self.get_queryset().for_company(company)


<span class="cm"># The payoff — reads like English, one DB hit:</span>
<span class="at">entries</span> = (
    JournalEntry.objects
    .for_company(company).posted().in_year(<span class="nm">2024</span>)
    .with_lines().with_totals().search(<span class="st">"payroll"</span>)
    .order_by(<span class="st">"-date"</span>)
)</code></pre>
      </div>
    </section>

    <!-- §10 AGGREGATIONS -->
    <section id="aggregations">
      <div class="section-eyebrow"><span class="section-num">§ 10</span><span class="section-tag">Level 3 — Advanced</span></div>
      <h2>aggregate() — <em>Collapse to One Dict</em></h2>
      <div class="section-rule"><div class="line"></div><div class="dot"></div><div class="line" style="max-width:60px"></div></div>

      <p><code>aggregate()</code> terminates the queryset and returns a Python dict. It maps to <code>SELECT SUM(...), COUNT(...) FROM ...</code> — one row returned, no GROUP BY.</p>

      <div class="code-block">
        <div class="code-header"><span>Python — aggregate()</span><button class="copy-btn" onclick="copyCode(this)">Copy</button></div>
        <pre><code><span class="kw">from</span> django.db.models <span class="kw">import</span> Sum, Avg, Max, Min, Count, StdDev
<span class="kw">from</span> django.db.models.functions <span class="kw">import</span> Coalesce
<span class="kw">from</span> django.db.models <span class="kw">import</span> DecimalField, Value

<span class="at">result</span> = JournalEntryLine.objects.filter(
    journal_entry__company=company,
    journal_entry__status=<span class="st">"posted"</span>,
    journal_entry__date__year=<span class="nm">2024</span>,
).aggregate(
    total_debit=Sum(<span class="st">"debit"</span>),
    total_credit=Sum(<span class="st">"credit"</span>),
    avg_debit=Avg(<span class="st">"debit"</span>),
    max_debit=Max(<span class="st">"debit"</span>),
    line_count=Count(<span class="st">"id"</span>),
    distinct_accounts=Count(<span class="st">"coa_account"</span>, distinct=<span class="kw">True</span>),
)
<span class="cm"># → {"total_debit": Decimal("1500000.00"), "line_count": 590, ...}</span>

<span class="cm"># Null handling — Sum returns None if no rows; coalesce with 0</span>
<span class="at">result</span> = JournalEntryLine.objects.filter(...).aggregate(
    total=Coalesce(Sum(<span class="st">"debit"</span>), Value(<span class="nm">0</span>), output_field=DecimalField())
)</code></pre>
      </div>
    </section>

    <!-- §11 ANNOTATIONS -->
    <section id="annotations">
      <div class="section-eyebrow"><span class="section-num">§ 11</span><span class="section-tag">Level 3 — Advanced</span></div>
      <h2>annotate() — <em>Computed Column Per Row</em></h2>
      <div class="section-rule"><div class="line"></div><div class="dot"></div><div class="line" style="max-width:60px"></div></div>

      <p><code>annotate()</code> is <code>aggregate()</code> applied per row. Each object in the resulting queryset gets the computed attribute attached. Maps to <code>SELECT ..., SUM(...) FROM ... GROUP BY (primary key)</code>.</p>

      <div class="code-block">
        <div class="code-header"><span>Python — annotate()</span><button class="copy-btn" onclick="copyCode(this)">Copy</button></div>
        <pre><code><span class="kw">from</span> django.db.models <span class="kw">import</span> Sum, Count, F, ExpressionWrapper, DecimalField, Q

<span class="cm"># Each JournalEntry gets total_debit, total_credit, line_count attached</span>
<span class="at">entries</span> = JournalEntry.objects.annotate(
    total_debit=Sum(<span class="st">"lines__debit"</span>),
    total_credit=Sum(<span class="st">"lines__credit"</span>),
    line_count=Count(<span class="st">"lines"</span>),
)
print(entries.first().total_debit)  <span class="cm"># Decimal — no extra query</span>

<span class="cm"># Filter on annotations — uses HAVING under the hood</span>
JournalEntry.objects.annotate(
    total_debit=Sum(<span class="st">"lines__debit"</span>)
).filter(total_debit__gte=<span class="nm">100000</span>)

<span class="cm"># F() expressions — compute at the DB level, no Python roundtrip</span>
JournalEntryLine.objects.annotate(
    net=ExpressionWrapper(
        F(<span class="st">"debit"</span>) <span class="op">-</span> F(<span class="st">"credit"</span>),
        output_field=DecimalField(max_digits=<span class="nm">18</span>, decimal_places=<span class="nm">2</span>)
    )
)

<span class="cm"># Field-to-field comparison with F()</span>
JournalEntryLine.objects.filter(debit=F(<span class="st">"credit"</span>))

<span class="cm"># Conditional aggregation — one query, multiple conditional counts/sums</span>
JournalEntry.objects.annotate(
    debit_line_count=Count(<span class="st">"lines"</span>, filter=Q(lines__debit__gt=<span class="nm">0</span>)),
    credit_line_count=Count(<span class="st">"lines"</span>, filter=Q(lines__credit__gt=<span class="nm">0</span>)),
    expense_line_total=Sum(<span class="st">"lines__debit"</span>, filter=Q(lines__coa_account__account_type=<span class="st">"expense"</span>)),
    revenue_line_total=Sum(<span class="st">"lines__credit"</span>, filter=Q(lines__coa_account__account_type=<span class="st">"revenue"</span>)),
)</code></pre>
      </div>
    </section>

    <!-- §12 GROUP BY -->
    <section id="groupby">
      <div class="section-eyebrow"><span class="section-num">§ 12</span><span class="section-tag">Level 3 — Advanced</span></div>
      <h2>values() + annotate() — <em>GROUP BY</em></h2>
      <div class="section-rule"><div class="line"></div><div class="dot"></div><div class="line" style="max-width:60px"></div></div>

      <p>When you put <code>values()</code> <strong>before</strong> <code>annotate()</code>, Django generates a <code>GROUP BY</code> on the values fields.</p>

      <div class="code-block">
        <div class="code-header"><span>Python — values() + annotate() = GROUP BY</span><button class="copy-btn" onclick="copyCode(this)">Copy</button></div>
        <pre><code><span class="cm"># Total debit and credit per account type</span>
ChartOfAccount.objects.values(<span class="st">"account_type"</span>).annotate(
    total_debit=Sum(<span class="st">"entry_lines__debit"</span>),
    total_credit=Sum(<span class="st">"entry_lines__credit"</span>),
    account_count=Count(<span class="st">"id"</span>),
).order_by(<span class="st">"account_type"</span>)

<span class="cm"># Monthly totals per cost center</span>
JournalEntryLine.objects.filter(
    journal_entry__status=<span class="st">"posted"</span>, journal_entry__company=company,
).values(
    <span class="st">"journal_entry__date__year"</span>,
    <span class="st">"journal_entry__date__month"</span>,
    <span class="st">"cost_center__name"</span>,
).annotate(
    total_debit=Sum(<span class="st">"debit"</span>),
    total_credit=Sum(<span class="st">"credit"</span>),
).order_by(<span class="st">"journal_entry__date__year"</span>, <span class="st">"journal_entry__date__month"</span>)

<span class="cm"># values_list with flat=True — great for id__in= filters</span>
<span class="at">posted_ids</span> = JournalEntry.objects.filter(status=<span class="st">"posted"</span>).values_list(<span class="st">"id"</span>, flat=<span class="kw">True</span>)
JournalEntryLine.objects.filter(journal_entry_id__in=posted_ids)</code></pre>
      </div>
    </section>

    <!-- §13 CASE/WHEN -->
    <section id="casewhen">
      <div class="section-eyebrow"><span class="section-num">§ 13</span><span class="section-tag">Level 3 — Advanced</span></div>
      <h2>Case / When — <em>Conditional Expressions</em></h2>
      <div class="section-rule"><div class="line"></div><div class="dot"></div><div class="line" style="max-width:60px"></div></div>

      <div class="code-block">
        <div class="code-header"><span>Python — Case/When</span><button class="copy-btn" onclick="copyCode(this)">Copy</button></div>
        <pre><code><span class="kw">from</span> django.db.models <span class="kw">import</span> Case, When, Value, IntegerField, CharField, DecimalField, F

<span class="cm"># Annotate each entry with a numeric sort priority</span>
JournalEntry.objects.annotate(
    priority=Case(
        When(status=<span class="st">"posted"</span>, then=Value(<span class="nm">3</span>)),
        When(status=<span class="st">"draft"</span>, then=Value(<span class="nm">2</span>)),
        When(status=<span class="st">"voided"</span>, then=Value(<span class="nm">1</span>)),
        default=Value(<span class="nm">0</span>),
        output_field=IntegerField(),
    )
).order_by(<span class="st">"-priority"</span>, <span class="st">"-date"</span>)

<span class="cm"># Conditional Sum — pivot into columns in ONE query</span>
JournalEntryLine.objects.filter(
    journal_entry__company=company, journal_entry__status=<span class="st">"posted"</span>,
).aggregate(
    expense_total=Sum(Case(
        When(coa_account__account_type=<span class="st">"expense"</span>, then=F(<span class="st">"debit"</span>)),
        default=Value(<span class="nm">0</span>),
        output_field=DecimalField(max_digits=<span class="nm">18</span>, decimal_places=<span class="nm">2</span>),
    )),
    revenue_total=Sum(Case(
        When(coa_account__account_type=<span class="st">"revenue"</span>, then=F(<span class="st">"credit"</span>)),
        default=Value(<span class="nm">0</span>),
        output_field=DecimalField(max_digits=<span class="nm">18</span>, decimal_places=<span class="nm">2</span>),
    )),
)

<span class="cm"># Conditional update per row in one statement</span>
JournalEntry.objects.filter(company=company).update(
    status=Case(
        When(approved_by__isnull=<span class="kw">False</span>, then=Value(<span class="st">"posted"</span>)),
        default=F(<span class="st">"status"</span>),
        output_field=models.CharField(),
    )
)</code></pre>
      </div>
    </section>

    <!-- §14 SUBQUERIES -->
    <section id="subqueries">
      <div class="section-eyebrow"><span class="section-num">§ 14</span><span class="section-tag">Level 3 — Advanced</span></div>
      <h2>Subqueries <em>&amp; OuterRef</em></h2>
      <div class="section-rule"><div class="line"></div><div class="dot"></div><div class="line" style="max-width:60px"></div></div>

      <p><code>Subquery</code> embeds a queryset as a SQL subquery. <code>OuterRef</code> references a field from the outer query — the Django equivalent of a correlated subquery. This avoids JOIN row multiplication.</p>

      <div class="code-block">
        <div class="code-header"><span>Python — Subquery, OuterRef, Exists</span><button class="copy-btn" onclick="copyCode(this)">Copy</button></div>
        <pre><code><span class="kw">from</span> django.db.models <span class="kw">import</span> OuterRef, Subquery, Exists

<span class="cm"># Annotate each JournalEntry with its latest line's description</span>
<span class="at">latest_line</span> = JournalEntryLine.objects.filter(
    journal_entry=OuterRef(<span class="st">"pk"</span>)
).order_by(<span class="st">"-id"</span>).values(<span class="st">"description"</span>)[:<span class="nm">1</span>]

JournalEntry.objects.annotate(
    latest_line_desc=Subquery(latest_line, output_field=models.TextField())
)

<span class="cm"># Annotate each ChartOfAccount with its most recent debit amount</span>
<span class="at">last_debit</span> = JournalEntryLine.objects.filter(
    coa_account=OuterRef(<span class="st">"pk"</span>), journal_entry__status=<span class="st">"posted"</span>,
).order_by(<span class="st">"-journal_entry__date"</span>, <span class="st">"-id"</span>).values(<span class="st">"debit"</span>)[:<span class="nm">1</span>]

ChartOfAccount.objects.annotate(
    last_debit_amount=Subquery(last_debit, output_field=models.DecimalField())
)

<span class="cm"># Exists() — very efficient "does a related row exist?" check</span>
<span class="at">has_expense_lines</span> = JournalEntryLine.objects.filter(
    journal_entry=OuterRef(<span class="st">"pk"</span>),
    coa_account__account_type=<span class="st">"expense"</span>,
)
JournalEntry.objects.annotate(has_expenses=Exists(has_expense_lines)).filter(has_expenses=<span class="kw">True</span>)

<span class="cm"># Multi-level OuterRef — reference the outer outer query</span>
<span class="at">latest_entry_for_account</span> = JournalEntry.objects.filter(
    company=OuterRef(OuterRef(<span class="st">"company"</span>)),   <span class="cm"># two levels up</span>
    lines__coa_account=OuterRef(<span class="st">"pk"</span>),
    status=<span class="st">"posted"</span>,
).order_by(<span class="st">"-date"</span>).values(<span class="st">"date"</span>)[:<span class="nm">1</span>]

ChartOfAccount.objects.annotate(
    last_used=Subquery(latest_entry_for_account, output_field=models.DateField())
)</code></pre>
      </div>
    </section>

    <!-- §15 BULK -->
    <section id="bulk">
      <div class="section-eyebrow"><span class="section-num">§ 15</span><span class="section-tag">Level 3 — Advanced</span></div>
      <h2>Bulk Operations — <em>Replace Python Loops</em></h2>
      <div class="section-rule"><div class="line"></div><div class="dot"></div><div class="line" style="max-width:60px"></div></div>

      <div class="callout info">
        <strong>bulk_create / bulk_update do NOT call .save()</strong>
        <p>Neither method triggers model signals or calls <code>.save()</code>. Do not rely on them for side effects. On PostgreSQL, <code>bulk_create</code> does populate IDs on returned instances.</p>
      </div>

      <div class="code-block">
        <div class="code-header"><span>Python — bulk operations</span><button class="copy-btn" onclick="copyCode(this)">Copy</button></div>
        <pre><code><span class="cm"># BULK CREATE — single INSERT (or batched)</span>
<span class="at">lines</span> = [
    JournalEntryLine(journal_entry=entry, coa_account=acc, debit=amount, description=desc)
    <span class="kw">for</span> acc, amount, desc <span class="kw">in</span> line_data
]
<span class="at">created</span> = JournalEntryLine.objects.bulk_create(lines, batch_size=<span class="nm">500</span>)

<span class="cm"># Upsert on PostgreSQL (Django 4.2+)</span>
JournalEntryLine.objects.bulk_create(
    lines, update_conflicts=<span class="kw">True</span>,
    unique_fields=[<span class="st">"journal_entry"</span>, <span class="st">"coa_account"</span>],
    update_fields=[<span class="st">"debit"</span>, <span class="st">"credit"</span>, <span class="st">"description"</span>],
)

<span class="cm"># BULK UPDATE — single UPDATE statement</span>
JournalEntryLine.objects.bulk_update(lines, fields=[<span class="st">"debit"</span>], batch_size=<span class="nm">500</span>)

<span class="cm"># UPDATE with F() expressions — the most efficient; no Python loop at all</span>
JournalEntryLine.objects.filter(
    journal_entry__company=company, journal_entry__status=<span class="st">"draft"</span>,
).update(debit=F(<span class="st">"debit"</span>) <span class="op">*</span> Decimal(<span class="st">"1.1"</span>))
<span class="cm"># → UPDATE ... SET debit = debit * 1.1 WHERE ...</span></code></pre>
      </div>
    </section>

    <!-- §16 WINDOWS -->
    <section id="windows">
      <div class="section-eyebrow"><span class="section-num">§ 16</span><span class="section-tag">Level 4 — Expert</span></div>
      <h2>Window Functions — <em>Analytics Without GROUP BY</em></h2>
      <div class="section-rule"><div class="line"></div><div class="dot"></div><div class="line" style="max-width:60px"></div></div>

      <p>Window functions compute a value "over a window" of related rows without collapsing them. Invaluable for rankings, running totals, moving averages, and lead/lag comparisons.</p>

      <div class="code-block">
        <div class="code-header"><span>Python — Window functions</span><button class="copy-btn" onclick="copyCode(this)">Copy</button></div>
        <pre><code><span class="kw">from</span> django.db.models <span class="kw">import</span> Window, Sum, Avg, Rank, DenseRank, RowNumber, F
<span class="kw">from</span> django.db.models.functions <span class="kw">import</span> Lag, Lead, FirstValue, LastValue
<span class="kw">from</span> django.db.models.expressions <span class="kw">import</span> RowRange

<span class="cm"># RUNNING TOTAL — cumulative debit per account, resets per account</span>
JournalEntryLine.objects.annotate(
    running_debit=Window(
        expression=Sum(<span class="st">"debit"</span>),
        partition_by=[F(<span class="st">"coa_account"</span>)],
        order_by=F(<span class="st">"journal_entry__date"</span>).asc(),
    )
)

<span class="cm"># RANK — Rank skips numbers on ties (1,2,2,4); DenseRank doesn't (1,2,2,3)</span>
JournalEntryLine.objects.annotate(
    rank_by_debit=Window(
        expression=Rank(),
        partition_by=[F(<span class="st">"coa_account"</span>)],
        order_by=F(<span class="st">"debit"</span>).desc(),
    ),
    row_number=Window(
        expression=RowNumber(),
        partition_by=[F(<span class="st">"coa_account"</span>)],
        order_by=F(<span class="st">"journal_entry__date"</span>).asc(),
    ),
)

<span class="cm"># LAG / LEAD — access previous or next row's value within the partition</span>
JournalEntryLine.objects.annotate(
    prev_debit=Window(
        expression=Lag(<span class="st">"debit"</span>, offset=<span class="nm">1</span>, default=<span class="nm">0</span>),
        partition_by=[F(<span class="st">"coa_account"</span>)],
        order_by=F(<span class="st">"journal_entry__date"</span>).asc(),
    ),
    next_debit=Window(
        expression=Lead(<span class="st">"debit"</span>, offset=<span class="nm">1</span>, default=<span class="nm">0</span>),
        partition_by=[F(<span class="st">"coa_account"</span>)],
        order_by=F(<span class="st">"journal_entry__date"</span>).asc(),
    ),
)

<span class="cm"># MOVING AVERAGE — 7-row sliding window (current + 6 preceding)</span>
JournalEntryLine.objects.annotate(
    moving_avg_debit=Window(
        expression=Avg(<span class="st">"debit"</span>),
        partition_by=[F(<span class="st">"coa_account"</span>)],
        order_by=F(<span class="st">"journal_entry__date"</span>).asc(),
        frame=RowRange(start=<span class="nm">-6</span>, end=<span class="nm">0</span>),
    )
)</code></pre>
      </div>
    </section>

    <!-- §17 RAW SQL -->
    <section id="rawsql">
      <div class="section-eyebrow"><span class="section-num">§ 17</span><span class="section-tag">Level 4 — Expert</span></div>
      <h2>Raw SQL — <em>When the ORM Can't Express It</em></h2>
      <div class="section-rule"><div class="line"></div><div class="dot"></div><div class="line" style="max-width:60px"></div></div>

      <p>The ORM covers ~95% of real-world queries. For the remaining 5%, use raw SQL — but always prefer <code>connection.cursor()</code> with parameterized queries over f-string interpolation, which is vulnerable to SQL injection.</p>

      <div class="code-block">
        <div class="code-header"><span>Python — cursor() for analytics queries</span><button class="copy-btn" onclick="copyCode(this)">Copy</button></div>
        <pre><code><span class="kw">from</span> django.db <span class="kw">import</span> connection

<span class="kw">def</span> <span class="fn">get_monthly_trial_balance</span>(company_id, year):
    <span class="kw">with</span> connection.cursor() <span class="kw">as</span> cursor:
        cursor.execute(
            <span class="st">"""
            WITH monthly_totals AS (
                SELECT
                    DATE_TRUNC('month', je.date)::DATE AS month,
                    jel.coa_account_id,
                    coa.code            AS account_code,
                    coa.name            AS account_name,
                    coa.account_type,
                    SUM(jel.debit)      AS total_debit,
                    SUM(jel.credit)     AS total_credit
                FROM journal_entry_line jel
                INNER JOIN journal_entry je ON je.id = jel.journal_entry_id
                INNER JOIN chart_of_account coa ON coa.id = jel.coa_account_id
                WHERE je.company_id = %s AND je.status = 'posted'
                  AND EXTRACT(year FROM je.date) = %s
                GROUP BY 1, 2, 3, 4, 5
            ),
            running_balance AS (
                SELECT *,
                    SUM(total_debit - total_credit) OVER (
                        PARTITION BY coa_account_id
                        ORDER BY month
                        ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW
                    ) AS running_balance
                FROM monthly_totals
            )
            SELECT * FROM running_balance ORDER BY account_code, month
            """</span>,
            [company_id, year]
        )
        <span class="at">columns</span> = [col[<span class="nm">0</span>] <span class="kw">for</span> col <span class="kw">in</span> cursor.description]
        <span class="kw">return</span> [dict(zip(columns, row)) <span class="kw">for</span> row <span class="kw">in</span> cursor.fetchall()]</code></pre>
      </div>
    </section>

    <!-- §18 INSPECTING -->
    <section id="inspecting">
      <div class="section-eyebrow"><span class="section-num">§ 18</span><span class="section-tag">Level 4 — Expert</span></div>
      <h2>Inspecting <em>Queries</em></h2>
      <div class="section-rule"><div class="line"></div><div class="dot"></div><div class="line" style="max-width:60px"></div></div>

      <div class="code-block">
        <div class="code-header"><span>Python — debugging & EXPLAIN</span><button class="copy-btn" onclick="copyCode(this)">Copy</button></div>
        <pre><code><span class="kw">from</span> django.db <span class="kw">import</span> connection, reset_queries

<span class="cm"># Requires DEBUG=True in settings</span>
reset_queries()
<span class="at">qs</span> = JournalEntry.objects.select_related(<span class="st">"company"</span>).prefetch_related(<span class="st">"lines"</span>)
list(qs)  <span class="cm"># force evaluation</span>

print(f<span class="st">"Queries fired: {len(connection.queries)}"</span>)
<span class="kw">for</span> q <span class="kw">in</span> connection.queries:
    print(f<span class="st">"[{q['time']}s] {q['sql']}\n"</span>)

<span class="cm"># Print the SQL for any queryset without executing it</span>
print(JournalEntry.objects.filter(status=<span class="st">"posted"</span>).query)

<span class="cm"># EXPLAIN — see the query plan (PostgreSQL)</span>
<span class="cm"># Look for: Seq Scan on large tables, high startup cost, nested loops with high row estimates</span>
print(
    JournalEntry.objects
    .filter(company=company, status=<span class="st">"posted"</span>)
    .select_related(<span class="st">"company"</span>)
    .explain(verbose=<span class="kw">True</span>, analyze=<span class="kw">True</span>)
)</code></pre>
      </div>
    </section>

    <!-- §19 OPTIMIZATION -->
    <section id="optimization">
      <div class="section-eyebrow"><span class="section-num">§ 19</span><span class="section-tag">Level 5 — Legend</span></div>
      <h2>only() &amp; defer() — <em>Surgical Field Loading</em></h2>
      <div class="section-rule"><div class="line"></div><div class="dot"></div><div class="line" style="max-width:60px"></div></div>

      <p><code>only()</code> tells Django to SELECT only the specified fields. <code>defer()</code> is the inverse — select everything EXCEPT the listed fields. Both reduce data transferred from the database.</p>

      <div class="callout danger">
        <strong>Accessing deferred fields causes N+1</strong>
        <p>If you <code>only("id", "status")</code> and then access <code>entry.description</code> in a loop, Django fires one extra SELECT per object. Know exactly which fields your code accesses.</p>
      </div>

      <div class="code-block">
        <div class="code-header"><span>Python — only() & defer()</span><button class="copy-btn" onclick="copyCode(this)">Copy</button></div>
        <pre><code><span class="cm"># only() — SELECT id, date, status FROM journal_entry WHERE ...</span>
<span class="at">entries</span> = JournalEntry.objects.only(<span class="st">"id"</span>, <span class="st">"date"</span>, <span class="st">"status"</span>)

<span class="cm"># defer() — SELECT everything EXCEPT description</span>
<span class="at">entries</span> = JournalEntry.objects.defer(<span class="st">"description"</span>)

<span class="cm"># only() with select_related — must include FK id fields explicitly</span>
JournalEntry.objects.only(
    <span class="st">"id"</span>, <span class="st">"date"</span>, <span class="st">"status"</span>,
    <span class="st">"company_id"</span>,    <span class="cm"># include the FK column</span>
    <span class="st">"company__name"</span>, <span class="cm"># also select company name via JOIN</span>
).select_related(<span class="st">"company"</span>)</code></pre>
      </div>
    </section>

    <!-- §20 ITERATOR -->
    <section id="iterator">
      <div class="section-eyebrow"><span class="section-num">§ 20</span><span class="section-tag">Level 5 — Legend</span></div>
      <h2>iterator() — <em>Stream Large QuerySets</em></h2>
      <div class="section-rule"><div class="line"></div><div class="dot"></div><div class="line" style="max-width:60px"></div></div>

      <p>Without <code>iterator()</code>, Django fetches the entire result set and holds it in memory. For large datasets (tens of thousands of rows), this can exhaust RAM.</p>

      <div class="callout warning">
        <strong>iterator() is incompatible with prefetch_related</strong>
        <p>If you need related data with <code>iterator()</code>, use <code>select_related</code> only — it uses a JOIN and works fine. <code>prefetch_related</code> requires the full queryset to be evaluated first.</p>
      </div>

      <div class="code-block">
        <div class="code-header"><span>Python — iterator()</span><button class="copy-btn" onclick="copyCode(this)">Copy</button></div>
        <pre><code><span class="cm"># Without iterator() — ALL rows loaded into Python memory simultaneously</span>
<span class="kw">for</span> entry <span class="kw">in</span> JournalEntry.objects.filter(status=<span class="st">"posted"</span>):
    process(entry)   <span class="cm"># 500,000 entries = 500,000 Python objects in RAM</span>

<span class="cm"># With iterator() — rows fetched in chunks, only chunk_size objects alive at once</span>
<span class="kw">for</span> entry <span class="kw">in</span> JournalEntry.objects.filter(status=<span class="st">"posted"</span>).iterator(chunk_size=<span class="nm">2000</span>):
    process(entry)

<span class="cm"># Combine with only() for maximum efficiency on large datasets</span>
<span class="kw">for</span> line <span class="kw">in</span> JournalEntryLine.objects.only(<span class="st">"id"</span>, <span class="st">"debit"</span>, <span class="st">"credit"</span>).iterator(chunk_size=<span class="nm">5000</span>):
    process(line)

<span class="cm"># With select_related — OK, uses JOIN, works with iterator()</span>
<span class="kw">for</span> entry <span class="kw">in</span> (
    JournalEntry.objects
    .select_related(<span class="st">"company"</span>, <span class="st">"created_by"</span>)
    .filter(status=<span class="st">"posted"</span>)
    .iterator(chunk_size=<span class="nm">1000</span>)
):
    process(entry)</code></pre>
      </div>
    </section>

    <!-- §21 LOCKING -->
    <section id="locking">
      <div class="section-eyebrow"><span class="section-num">§ 21</span><span class="section-tag">Level 5 — Legend</span></div>
      <h2>select_for_update() — <em>Pessimistic Locking</em></h2>
      <div class="section-rule"><div class="line"></div><div class="dot"></div><div class="line" style="max-width:60px"></div></div>

      <p>When multiple processes might modify the same rows concurrently, use database-level locking. <code>select_for_update()</code> issues <code>SELECT ... FOR UPDATE</code>. Must be inside <code>transaction.atomic()</code>.</p>

      <div class="code-block">
        <div class="code-header"><span>Python — select_for_update()</span><button class="copy-btn" onclick="copyCode(this)">Copy</button></div>
        <pre><code><span class="kw">from</span> django.db <span class="kw">import</span> transaction

<span class="cm"># Lock a single row — no other transaction can UPDATE or DELETE until we commit</span>
<span class="kw">with</span> transaction.atomic():
    <span class="at">entry</span> = JournalEntry.objects.select_for_update().get(id=entry_id)
    <span class="kw">if</span> entry.status != <span class="st">"draft"</span>:
        <span class="kw">raise</span> ValueError(<span class="st">"Only draft entries can be posted"</span>)
    entry.status = <span class="st">"posted"</span>
    entry.save()

<span class="cm"># nowait=True — raise DatabaseError immediately if lock is unavailable</span>
<span class="kw">with</span> transaction.atomic():
    <span class="kw">try</span>:
        <span class="at">entry</span> = JournalEntry.objects.select_for_update(nowait=<span class="kw">True</span>).get(id=entry_id)
    <span class="kw">except</span> Exception:
        <span class="kw">raise</span> ValueError(<span class="st">"Entry is currently being modified by another process"</span>)

<span class="cm"># skip_locked=True — skip locked rows; perfect for job queues / worker pools</span>
<span class="kw">with</span> transaction.atomic():
    <span class="at">entries</span> = JournalEntry.objects.select_for_update(skip_locked=<span class="kw">True</span>).filter(status=<span class="st">"draft"</span>)[:<span class="nm">10</span>]
    <span class="kw">for</span> entry <span class="kw">in</span> entries:
        process_and_post(entry)

<span class="cm"># of= — lock only specific tables (PostgreSQL)</span>
<span class="kw">with</span> transaction.atomic():
    <span class="at">entry</span> = JournalEntry.objects.select_related(<span class="st">"company"</span>).select_for_update(
        of=(<span class="st">"self"</span>,)   <span class="cm"># lock journal_entry only, not company</span>
    ).get(id=entry_id)</code></pre>
      </div>
    </section>

    <!-- §22 TRANSACTIONS -->
    <section id="transactions">
      <div class="section-eyebrow"><span class="section-num">§ 22</span><span class="section-tag">Level 5 — Legend</span></div>
      <h2>Atomic Transactions — <em>All or Nothing</em></h2>
      <div class="section-rule"><div class="line"></div><div class="dot"></div><div class="line" style="max-width:60px"></div></div>

      <div class="code-block">
        <div class="code-header"><span>Python — transactions, savepoints, on_commit</span><button class="copy-btn" onclick="copyCode(this)">Copy</button></div>
        <pre><code><span class="kw">from</span> django.db <span class="kw">import</span> transaction

<span class="cm"># Decorator — entire function runs in one transaction</span>
<span class="dc">@transaction.atomic</span>
<span class="kw">def</span> <span class="fn">post_journal_entry</span>(entry_id: int, approved_by_id: int) <span class="op">-></span> JournalEntry:
    <span class="at">entry</span> = JournalEntry.objects.select_for_update().get(id=entry_id)
    <span class="kw">if</span> entry.status != <span class="st">"draft"</span>:
        <span class="kw">raise</span> ValueError(f<span class="st">"Cannot post entry with status '{entry.status}'"</span>)

    <span class="at">totals</span> = entry.lines.aggregate(total_debit=Sum(<span class="st">"debit"</span>), total_credit=Sum(<span class="st">"credit"</span>))
    <span class="kw">if</span> totals[<span class="st">"total_debit"</span>] != totals[<span class="st">"total_credit"</span>]:
        <span class="kw">raise</span> ValueError(<span class="st">"Entry is unbalanced"</span>)

    <span class="kw">from</span> django.utils <span class="kw">import</span> timezone
    entry.status = <span class="st">"posted"</span>
    entry.approved_by_id = approved_by_id
    entry.approved_at = timezone.now()
    entry.save(update_fields=[<span class="st">"status"</span>, <span class="st">"approved_by_id"</span>, <span class="st">"approved_at"</span>, <span class="st">"updated_at"</span>])
    <span class="kw">return</span> entry


<span class="cm"># Context manager with savepoints</span>
<span class="kw">def</span> <span class="fn">create_entry_with_lines</span>(header_data, lines_data):
    <span class="kw">with</span> transaction.atomic():
        <span class="at">entry</span> = JournalEntry.objects.create(<span class="op">**</span>header_data)
        JournalEntryLine.objects.bulk_create([
            JournalEntryLine(journal_entry=entry, <span class="op">**</span>ld) <span class="kw">for</span> ld <span class="kw">in</span> lines_data
        ])

        <span class="cm"># Savepoint — partial rollback if optional step fails</span>
        <span class="kw">try</span>:
            <span class="kw">with</span> transaction.atomic():
                send_notification(entry)  <span class="cm"># optional, non-critical</span>
        <span class="kw">except</span> Exception:
            <span class="kw">pass</span>  <span class="cm"># savepoint rolled back; outer transaction proceeds</span>

        <span class="kw">return</span> entry


<span class="cm"># on_commit — run ONLY after the transaction successfully commits</span>
<span class="cm"># Use for emails, Celery tasks, webhooks — NOT if transaction rolls back</span>
<span class="kw">def</span> <span class="fn">post_entry</span>(entry_id):
    <span class="kw">with</span> transaction.atomic():
        <span class="at">entry</span> = JournalEntry.objects.select_for_update().get(id=entry_id)
        entry.status = <span class="st">"posted"</span>
        entry.save()
        transaction.on_commit(<span class="kw">lambda</span>: send_posting_email.delay(entry_id))
        transaction.on_commit(<span class="kw">lambda</span>: sync_to_erp.delay(entry_id))</code></pre>
      </div>
    </section>

    <!-- §23 INDEXES -->
    <section id="indexes">
      <div class="section-eyebrow"><span class="section-num">§ 23</span><span class="section-tag">Level 5 — Legend</span></div>
      <h2>Indexes — <em>The Highest-Impact Optimization</em></h2>
      <div class="section-rule"><div class="line"></div><div class="dot"></div><div class="line" style="max-width:60px"></div></div>

      <p>No amount of ORM optimization compensates for a missing index on a hot query path. Understanding which indexes to create — and which waste space — separates senior engineers from the rest.</p>

      <div class="code-block">
        <div class="code-header"><span>Python — index patterns</span><button class="copy-btn" onclick="copyCode(this)">Copy</button></div>
        <pre><code><span class="kw">class</span> <span class="fn">JournalEntry</span>(<span class="fn">TimestampedModel</span>):
    <span class="kw">class</span> <span class="fn">Meta</span>:
        <span class="at">indexes</span> = [
            <span class="cm"># Composite index — covers WHERE company_id = X AND date BETWEEN ...</span>
            <span class="cm"># Column order matters: most selective filter first</span>
            models.Index(fields=[<span class="st">"company"</span>, <span class="st">"date"</span>], name=<span class="st">"je_company_date_idx"</span>),

            <span class="cm"># Partial index (PostgreSQL) — indexes ONLY posted entries</span>
            <span class="cm"># Much smaller and faster than indexing all statuses</span>
            models.Index(
                fields=[<span class="st">"company"</span>, <span class="st">"date"</span>],
                condition=models.Q(status=<span class="st">"posted"</span>),
                name=<span class="st">"je_company_date_posted_idx"</span>,
            ),
            models.Index(fields=[<span class="st">"company"</span>, <span class="st">"status"</span>], name=<span class="st">"je_company_status_idx"</span>),
        ]

<span class="cm"># When NOT to add an index:
# - Low cardinality columns (boolean, status with 2 values) — full scan is faster
# - Tables < ~10,000 rows — overhead exceeds benefit
# - Write-only columns never used in filters
# - Already covered by leftmost columns of another composite index</span>

<span class="cm"># How to detect missing indexes:
# .explain(analyze=True) and look for "Seq Scan" on large tables</span></code></pre>
      </div>
    </section>

    <!-- §24 NESTED EXAMPLE -->
    <section id="nested">
      <div class="section-eyebrow"><span class="section-num">§ 24</span><span class="section-tag">Level 5 — Legend</span></div>
      <h2>The Heavily Nested <em>Example</em></h2>
      <div class="section-rule"><div class="line"></div><div class="dot"></div><div class="line" style="max-width:60px"></div></div>

      <p>A single queryset combining <code>select_related</code>, <code>prefetch_related</code>, nested <code>select_related</code> inside <code>Prefetch</code>, <code>annotate</code>, <code>Subquery</code>, <code>OuterRef</code>, <code>Exists</code>, <code>Case/When</code>, <code>F()</code>, <code>Window</code>, and <code>Q</code> objects. Total DB queries for a full financial dashboard: <strong>3</strong>.</p>

      <div class="pull-quote">
        <p>"Three DB queries. A full financial dashboard. Zero loops hitting the database."</p>
      </div>

      <div class="code-block">
        <div class="code-header"><span>Python — the complete dashboard query</span><button class="copy-btn" onclick="copyCode(this)">Copy</button></div>
        <pre><code><span class="kw">from</span> django.db.models <span class="kw">import</span> (
    Sum, Count, F, Q, Value, Case, When,
    OuterRef, Subquery, Exists, Window, Rank,
    DecimalField, CharField, BooleanField, ExpressionWrapper, Prefetch,
)
<span class="kw">from</span> django.db.models.functions <span class="kw">import</span> Coalesce


<span class="kw">def</span> <span class="fn">get_dashboard_entries</span>(company, date_from, date_to, min_amount=<span class="nm">0</span>, approver=<span class="kw">None</span>):

    <span class="cm"># ── Subquery 1: account name of the highest debit line per entry ──</span>
    <span class="at">largest_debit_line</span> = (
        JournalEntryLine.objects
        .filter(journal_entry=OuterRef(<span class="st">"pk"</span>))
        .order_by(<span class="st">"-debit"</span>)
        .values(<span class="st">"coa_account__name"</span>)[:<span class="nm">1</span>]
    )

    <span class="cm"># ── Subquery 2: year-to-date budget total for the company ──</span>
    <span class="at">ytd_budget</span> = (
        Budget.objects
        .filter(company=OuterRef(<span class="st">"company"</span>), year=date_from.year, month__lte=date_from.month)
        .values(<span class="st">"company"</span>).annotate(total=Sum(<span class="st">"amount"</span>)).values(<span class="st">"total"</span>)[:<span class="nm">1</span>]
    )

    <span class="cm"># ── Subquery 3: does this entry have any expense-type lines? ──</span>
    <span class="at">has_expense</span> = Exists(
        JournalEntryLine.objects.filter(
            journal_entry=OuterRef(<span class="st">"pk"</span>),
            coa_account__account_type=<span class="st">"expense"</span>,
        )
    )

    <span class="cm"># ── Prefetch: lines with FKs and an annotated net field ──</span>
    <span class="at">lines_prefetch</span> = Prefetch(
        <span class="st">"lines"</span>,
        queryset=(
            JournalEntryLine.objects
            .select_related(
                <span class="st">"coa_account"</span>, <span class="st">"coa_account__parent"</span>,
                <span class="st">"cost_center"</span>, <span class="st">"cost_center__parent"</span>,
            )
            .order_by(<span class="st">"coa_account__code"</span>)
            .annotate(
                net=ExpressionWrapper(
                    F(<span class="st">"debit"</span>) <span class="op">-</span> F(<span class="st">"credit"</span>),
                    output_field=DecimalField(max_digits=<span class="nm">18</span>, decimal_places=<span class="nm">2</span>),
                )
            )
        ),
        to_attr=<span class="st">"prefetched_lines"</span>,
    )

    <span class="cm"># ── Dynamic Q filter ──</span>
    <span class="at">dynamic_filter</span> = Q(total_debit__gte=min_amount)
    <span class="kw">if</span> approver:
        <span class="at">dynamic_filter</span> <span class="op">|=</span> Q(approved_by=approver)

    <span class="cm"># ── The main queryset ──</span>
    <span class="kw">return</span> (
        JournalEntry.objects
        .select_related(<span class="st">"company"</span>, <span class="st">"created_by"</span>, <span class="st">"approved_by"</span>)
        .prefetch_related(lines_prefetch)
        .filter(company=company, status=<span class="st">"posted"</span>, date__range=(date_from, date_to))
        .annotate(
            total_debit=Coalesce(Sum(<span class="st">"lines__debit"</span>), Value(<span class="nm">0</span>), output_field=DecimalField(max_digits=<span class="nm">18</span>, decimal_places=<span class="nm">2</span>)),
            total_credit=Coalesce(Sum(<span class="st">"lines__credit"</span>), Value(<span class="nm">0</span>), output_field=DecimalField(max_digits=<span class="nm">18</span>, decimal_places=<span class="nm">2</span>)),
            line_count=Count(<span class="st">"lines"</span>, distinct=<span class="kw">True</span>),
            is_balanced=Case(
                When(total_debit=F(<span class="st">"total_credit"</span>), then=Value(<span class="kw">True</span>)),
                default=Value(<span class="kw">False</span>), output_field=BooleanField(),
            ),
            status_label=Case(
                When(status=<span class="st">"posted"</span>, approved_by__isnull=<span class="kw">False</span>, then=Value(<span class="st">"Posted &amp; Approved"</span>)),
                When(status=<span class="st">"posted"</span>, approved_by__isnull=<span class="kw">True</span>,  then=Value(<span class="st">"Posted, Pending Approval"</span>)),
                When(status=<span class="st">"draft"</span>, then=Value(<span class="st">"Draft"</span>)),
                When(status=<span class="st">"voided"</span>, then=Value(<span class="st">"Voided"</span>)),
                default=Value(<span class="st">"Unknown"</span>), output_field=CharField(),
            ),
            largest_debit_account=Subquery(largest_debit_line, output_field=CharField()),
            ytd_budget_total=Subquery(ytd_budget, output_field=DecimalField(max_digits=<span class="nm">18</span>, decimal_places=<span class="nm">2</span>)),
            has_expense_lines=has_expense,
            budget_variance=ExpressionWrapper(
                Coalesce(Sum(<span class="st">"lines__debit"</span>), Value(<span class="nm">0</span>), output_field=DecimalField()) <span class="op">-</span>
                Coalesce(Subquery(ytd_budget, output_field=DecimalField()), Value(<span class="nm">0</span>), output_field=DecimalField()),
                output_field=DecimalField(max_digits=<span class="nm">18</span>, decimal_places=<span class="nm">2</span>),
            ),
            debit_rank=Window(expression=Rank(), order_by=F(<span class="st">"total_debit"</span>).desc()),
            expense_line_count=Count(<span class="st">"lines"</span>, filter=Q(lines__coa_account__account_type=<span class="st">"expense"</span>)),
            revenue_line_count=Count(<span class="st">"lines"</span>, filter=Q(lines__coa_account__account_type=<span class="st">"revenue"</span>)),
        )
        .filter(dynamic_filter)
        .order_by(<span class="st">"debit_rank"</span>, <span class="st">"-date"</span>)
    )


<span class="cm"># ── Usage — zero extra queries in the loop ──</span>
<span class="kw">from</span> datetime <span class="kw">import</span> date

<span class="at">entries</span> = get_dashboard_entries(
    company=company, date_from=date(<span class="nm">2024</span>, <span class="nm">1</span>, <span class="nm">1</span>), date_to=date(<span class="nm">2024</span>, <span class="nm">12</span>, <span class="nm">31</span>),
    min_amount=<span class="nm">5000</span>, approver=request.user,
)

<span class="kw">for</span> entry <span class="kw">in</span> entries:
    print(entry.company.name)           <span class="cm"># select_related — no query</span>
    print(entry.status_label)           <span class="cm"># Case/When annotation</span>
    print(entry.is_balanced)            <span class="cm"># annotation</span>
    print(f<span class="st">"Rank #{entry.debit_rank}"</span>)  <span class="cm"># Window annotation</span>
    print(entry.budget_variance)        <span class="cm"># compound annotation</span>

    <span class="kw">for</span> line <span class="kw">in</span> entry.prefetched_lines:              <span class="cm"># prefetched list — no query</span>
        print(line.coa_account.name)                 <span class="cm"># select_related</span>
        <span class="kw">if</span> line.coa_account.parent:
            print(line.coa_account.parent.name)      <span class="cm"># select_related</span>
        <span class="kw">if</span> line.cost_center:
            print(line.cost_center.name)             <span class="cm"># select_related</span>
        print(line.net)                              <span class="cm"># annotated on line</span>

<span class="cm"># Total DB queries for the entire above loop: 3
# Query 1: the main JournalEntry queryset (with all JOINs from select_related)
# Query 2: the prefetch_related lines query (with JOINs for coa_account, cost_center, parents)
# Query 3: (none — everything is cached)</span></code></pre>
      </div>
    </section>

    <!-- §25 CHECKLIST -->
    <section id="checklist">
      <div class="section-eyebrow"><span class="section-num">§ 25</span><span class="section-tag">Production</span></div>
      <h2>The N+1 Killer <em>Checklist</em></h2>
      <div class="section-rule"><div class="line"></div><div class="dot"></div><div class="line" style="max-width:60px"></div></div>

      <div class="checklist-group">
        <h4>Relationship Coverage</h4>
        <ul class="checklist">
          <li>Every FK accessed in code or serializer → <code>select_related</code></li>
          <li>Every reverse FK or M2M → <code>prefetch_related</code></li>
          <li>Every FK on a prefetched object → nested <code>select_related</code> inside <code>Prefetch()</code></li>
        </ul>
      </div>

      <div class="checklist-group">
        <h4>Loop Hygiene</h4>
        <ul class="checklist">
          <li>No <code>.save()</code>, <code>.update()</code>, or <code>.create()</code> inside a for loop</li>
          <li>Replace with <code>bulk_update</code>, <code>bulk_create</code>, or queryset-level <code>.update()</code> with <code>F()</code></li>
        </ul>
      </div>

      <div class="checklist-group">
        <h4>Efficiency Rules</h4>
        <ul class="checklist">
          <li>Use <code>.only()</code> or <code>.values()</code> when accessing a small subset of fields</li>
          <li>Use <code>aggregate()</code> or <code>annotate()</code> instead of summing/counting in Python</li>
          <li>Use <code>.exists()</code> for boolean checks, never <code>len(qs) > 0</code></li>
          <li>Use <code>.iterator(chunk_size=N)</code> for queries returning more than ~10,000 rows</li>
        </ul>
      </div>

      <div class="checklist-group">
        <h4>Correctness & Safety</h4>
        <ul class="checklist">
          <li>Multi-row operations that must succeed/fail together → <code>transaction.atomic()</code></li>
          <li>Side effects (emails, tasks) → <code>transaction.on_commit()</code></li>
          <li>Read-then-write patterns → <code>select_for_update()</code> inside <code>atomic()</code></li>
          <li>Every field in a <code>.filter()</code> that isn't PK should have an index</li>
          <li>Run <code>.explain(analyze=True)</code> and check for <code>Seq Scan</code> on large tables</li>
          <li>Any view returning a list of objects should fire at most 2–3 queries</li>
        </ul>
      </div>
    </section>

    <!-- §26 CHEAT SHEET -->
    <section id="cheatsheet">
      <div class="section-eyebrow"><span class="section-num">§ 26</span><span class="section-tag">Reference</span></div>
      <h2>The Legend <em>Cheat Sheet</em></h2>
      <div class="section-rule"><div class="line"></div><div class="dot"></div><div class="line" style="max-width:60px"></div></div>

      <table class="data-table">
        <thead><tr><th>Situation</th><th>Tool</th><th>Notes</th></tr></thead>
        <tbody>
          <tr><td>FK / OneToOne in code or serializer</td><td><code>select_related</code></td><td>SQL JOIN — one query</td></tr>
          <tr><td>Reverse FK / M2M in code or serializer</td><td><code>prefetch_related</code></td><td>2 queries total</td></tr>
          <tr><td>Filter or annotate the prefetched set</td><td><code>Prefetch(queryset=...)</code></td><td>Full control</td></tr>
          <tr><td>Store prefetch as a list attribute</td><td><code>Prefetch(to_attr=...)</code></td><td>Avoids <code>.all()</code> call</td></tr>
          <tr><td>FK on a prefetched object</td><td>Nested <code>select_related</code> inside <code>Prefetch</code></td><td>Prevents N+1 inside prefetch</td></tr>
          <tr><td>Load only specific fields</td><td><code>.only("field1", "field2")</code></td><td>Deferred access = extra query</td></tr>
          <tr><td>Skip heavy fields</td><td><code>.defer("large_text_field")</code></td><td>Load on demand</td></tr>
          <tr><td>OR / NOT logic</td><td><code>Q</code> objects</td><td>Composable with <code>&amp;</code>, <code>|</code>, <code>~</code></td></tr>
          <tr><td>Build filters dynamically</td><td><code>Q()</code> accumulator with <code>&amp;=</code> / <code>|=</code></td><td>Clean pattern for search APIs</td></tr>
          <tr><td>Collapse queryset to a single dict</td><td><code>aggregate()</code></td><td>Terminates queryset</td></tr>
          <tr><td>Add computed column per row</td><td><code>annotate()</code></td><td>Chainable, filterable</td></tr>
          <tr><td>GROUP BY</td><td><code>.values(...).annotate(...)</code></td><td>Order matters: values before annotate</td></tr>
          <tr><td>Reference row field in expression</td><td><code>F("field")</code></td><td>No Python roundtrip</td></tr>
          <tr><td>Conditional column</td><td><code>Case(When(..., then=...), default=...)</code></td><td>SQL CASE WHEN</td></tr>
          <tr><td>Correlated subquery</td><td><code>Subquery(qs) + OuterRef("pk")</code></td><td>Avoids JOIN row multiplication</td></tr>
          <tr><td>Efficient "does related row exist"</td><td><code>Exists(qs)</code></td><td>SELECT 1 WHERE EXISTS</td></tr>
          <tr><td>Running totals / rankings / lag</td><td><code>Window(expression=..., partition_by=..., order_by=...)</code></td><td>DB-level analytics</td></tr>
          <tr><td>Return dicts (no model instances)</td><td><code>.values(...)</code></td><td>Faster for projections</td></tr>
          <tr><td>Return flat list of one field</td><td><code>.values_list("field", flat=True)</code></td><td>Great for <code>id__in=</code></td></tr>
          <tr><td>Insert many rows efficiently</td><td><code>bulk_create(list, batch_size=N)</code></td><td>Single INSERT</td></tr>
          <tr><td>Update many rows efficiently</td><td><code>bulk_update(list, fields=[...])</code></td><td>Single UPDATE</td></tr>
          <tr><td>Update all rows matching filter</td><td><code>.update(field=F("field") * 2)</code></td><td>No Python loop at all</td></tr>
          <tr><td>Process millions of rows without OOM</td><td><code>.iterator(chunk_size=N)</code></td><td>Incompatible with prefetch</td></tr>
          <tr><td>Race-condition-safe read+write</td><td><code>select_for_update()</code> inside <code>atomic()</code></td><td>SELECT FOR UPDATE</td></tr>
          <tr><td>Skip locked rows (worker pattern)</td><td><code>select_for_update(skip_locked=True)</code></td><td>Multi-worker queue</td></tr>
          <tr><td>Fail fast if locked</td><td><code>select_for_update(nowait=True)</code></td><td>Raises immediately</td></tr>
          <tr><td>All-or-nothing writes</td><td><code>transaction.atomic()</code></td><td>Decorator or context manager</td></tr>
          <tr><td>Savepoint (partial rollback)</td><td>Nested <code>transaction.atomic()</code></td><td>Inner rollback, outer proceeds</td></tr>
          <tr><td>Side effects after commit</td><td><code>transaction.on_commit(fn)</code></td><td>Emails, Celery tasks</td></tr>
          <tr><td>Inspect query plan</td><td><code>.explain(analyze=True)</code></td><td>Look for Seq Scan</td></tr>
          <tr><td>Count queries in tests</td><td><code>connection.queries + reset_queries()</code></td><td>Requires DEBUG=True</td></tr>
          <tr><td>Partial index (PostgreSQL)</td><td><code>Index(fields=..., condition=Q(...))</code></td><td>Index subset of rows</td></tr>
          <tr><td>Encapsulate query logic</td><td>Custom <code>QuerySet + Manager</code></td><td>Chainable, reusable methods</td></tr>
        </tbody>
      </table>
    </section>

  </main>
</div>

<footer>
  <p>The Ultimate Django Querying Guide · From Beginner to Legend · Production-Grade Reference</p>
  <p>docs.djangoproject.com/en/stable/topics/db/queries/ · All examples use the accounting schema from §01</p>
</footer>

<script>
function copyCode(btn) {
  const pre = btn.closest('.code-block').querySelector('pre');
  navigator.clipboard.writeText(pre.innerText).then(() => {
    const orig = btn.textContent;
    btn.textContent = 'Copied!';
    btn.style.color = 'var(--green)';
    btn.style.borderColor = 'var(--green)';
    setTimeout(() => { btn.textContent = orig; btn.style.color = ''; btn.style.borderColor = ''; }, 2000);
  });
}
</script>
</body>
</html>